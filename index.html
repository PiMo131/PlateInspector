<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Röntgen Analyse — Kogelwerende Platen</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Barlow+Condensed:wght@300;400;600;700&display=swap');
  :root {
    --bg:#0a0c0f; --panel:#0f1318; --border:#1e2630;
    --accent:#00e5ff; --accent2:#ff4444; --accent3:#39ff14;
    --text:#b8c5d0; --text-dim:#4a5568;
    --mono:'Share Tech Mono',monospace; --sans:'Barlow Condensed',sans-serif;
  }
  *{box-sizing:border-box;margin:0;padding:0;}
  body{background:var(--bg);color:var(--text);font-family:var(--sans);
    height:100vh;display:grid;grid-template-rows:48px 1fr;
    grid-template-columns:280px 1fr;overflow:hidden;}

  /* HEADER */
  header{grid-column:1/-1;background:var(--panel);border-bottom:1px solid var(--border);
    display:flex;align-items:center;gap:12px;padding:0 16px;}
  .logo{font-family:var(--mono);font-size:13px;color:var(--accent);letter-spacing:3px;text-transform:uppercase;}
  .sep{width:1px;height:20px;background:var(--border);}
  .subtitle{font-size:11px;color:var(--text-dim);letter-spacing:2px;text-transform:uppercase;}
  .hdr-status{margin-left:auto;font-family:var(--mono);font-size:11px;color:var(--text-dim);}
  .hdr-status span{color:var(--accent3);}
  .hdr-btn{display:flex;align-items:center;gap:6px;padding:6px 12px;
    border:1px solid var(--border);background:transparent;color:var(--text-dim);
    font-family:var(--mono);font-size:10px;letter-spacing:2px;text-transform:uppercase;
    cursor:pointer;border-radius:3px;transition:all .15s;white-space:nowrap;}
  .hdr-btn:hover{border-color:var(--accent);color:var(--accent);background:rgba(0,229,255,.06);}
  .hdr-btn.flash{border-color:var(--accent3);color:var(--accent3);background:rgba(57,255,20,.1);}
  .hdr-btn svg{width:13px;height:13px;fill:none;stroke:currentColor;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;}
  .hdr-btn.report-btn{border-color:rgba(0,229,255,.3);}
  .hdr-btn.report-btn:hover{border-color:var(--accent);}

  /* SIDEBAR */
  aside{background:var(--panel);border-right:1px solid var(--border);
    padding:16px;overflow-y:auto;display:flex;flex-direction:column;gap:18px;}
  .sec-title{font-family:var(--mono);font-size:10px;letter-spacing:3px;text-transform:uppercase;
    color:var(--accent);margin-bottom:10px;padding-bottom:6px;border-bottom:1px solid var(--border);}
  .dropzone{border:1px dashed var(--border);border-radius:4px;padding:20px 12px;
    text-align:center;cursor:pointer;transition:all .2s;position:relative;}
  .dropzone:hover,.dropzone.dragover{border-color:var(--accent);background:rgba(0,229,255,.04);}
  .dropzone input{position:absolute;inset:0;opacity:0;cursor:pointer;}
  .dropzone .dz-icon{font-size:26px;margin-bottom:6px;}
  .dropzone .dz-text{font-size:12px;color:var(--text-dim);line-height:1.5;}
  .dropzone .dz-text strong{color:var(--text);}
  .error-box{background:rgba(255,68,68,.08);border:1px solid var(--accent2);
    border-radius:4px;padding:10px;font-family:var(--mono);font-size:11px;
    line-height:1.6;color:var(--accent2);display:none;margin-top:8px;}

  /* CONTROLS */
  label.ctrl{display:flex;flex-direction:column;gap:5px;}
  label.ctrl .lbl{font-size:11px;letter-spacing:1px;color:var(--text-dim);
    display:flex;justify-content:space-between;}
  label.ctrl .lbl span{color:var(--text);font-family:var(--mono);}
  input[type=range]{-webkit-appearance:none;width:100%;height:3px;
    background:var(--border);border-radius:2px;outline:none;}
  input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:12px;height:12px;
    border-radius:50%;background:var(--accent);cursor:pointer;}
  .btn-group{display:flex;gap:5px;flex-wrap:wrap;}
  .btn{flex:1;min-width:50px;padding:6px 6px;border:1px solid var(--border);
    background:transparent;color:var(--text-dim);font-family:var(--mono);font-size:10px;
    letter-spacing:1px;text-transform:uppercase;cursor:pointer;border-radius:3px;
    transition:all .15s;text-align:center;}
  .btn:hover{border-color:var(--accent);color:var(--accent);}
  .btn.active{background:rgba(0,229,255,.12);border-color:var(--accent);color:var(--accent);}
  .btn.danger:hover,.btn.danger.active{border-color:var(--accent2);color:var(--accent2);background:rgba(255,68,68,.08);}
  .btn.success:hover,.btn.success.active{border-color:var(--accent3);color:var(--accent3);background:rgba(57,255,20,.08);}
  .mode-btn{display:flex;align-items:center;gap:8px;padding:8px 10px;
    border:1px solid var(--border);background:transparent;color:var(--text-dim);
    font-family:var(--sans);font-size:13px;cursor:pointer;border-radius:3px;
    transition:all .15s;width:100%;}
  .mode-btn:hover{border-color:var(--accent);color:var(--text);}
  .mode-btn.active{background:rgba(0,229,255,.08);border-color:var(--accent);color:var(--accent);}
  .mode-btn .dot{width:7px;height:7px;border-radius:50%;border:1.5px solid currentColor;flex-shrink:0;}
  .mode-btn.active .dot{background:currentColor;}
  .info-box{background:rgba(0,0,0,.3);border:1px solid var(--border);border-radius:4px;
    padding:10px;font-family:var(--mono);font-size:11px;line-height:1.8;color:var(--text-dim);}
  .info-box .val{color:var(--text);}
  .small-info{font-family:var(--mono);font-size:9px;color:var(--text-dim);
    line-height:1.6;padding:6px 8px;background:rgba(57,255,20,.05);
    border:1px solid rgba(57,255,20,.15);border-radius:3px;margin-top:4px;}

  /* MAIN */
  main{position:relative;overflow:hidden;
    background:linear-gradient(rgba(255,255,255,.015) 1px,transparent 1px),
               linear-gradient(90deg,rgba(255,255,255,.015) 1px,transparent 1px);
    background-size:40px 40px;background-color:#070910;cursor:crosshair;}
  #canvas-wrapper{position:absolute;top:50%;left:50%;
    transform:translate(-50%,-50%) scale(1);transform-origin:center center;line-height:0;}
  #mainCanvas{display:block;image-rendering:pixelated;}
  #overlayCanvas,#uiCanvas{position:absolute;top:0;left:0;image-rendering:pixelated;}
  #overlayCanvas{pointer-events:none;}
  #uiCanvas{pointer-events:none;}
  #uiCanvas.active{pointer-events:auto;cursor:crosshair;}

  #drop-overlay{position:absolute;inset:0;display:flex;flex-direction:column;
    align-items:center;justify-content:center;gap:16px;pointer-events:none;}
  #drop-overlay .big-icon{font-size:64px;opacity:.15;}
  #drop-overlay .msg{font-family:var(--mono);font-size:13px;letter-spacing:3px;
    color:var(--text-dim);text-transform:uppercase;}

  /* MAGNIFIER */
  #magnifier{position:fixed;border-radius:50%;border:2px solid var(--accent);
    box-shadow:0 0 20px rgba(0,229,255,.3);pointer-events:none;display:none;
    overflow:hidden;z-index:1000;transform:translate(-50%,-50%);}
  #magnifier canvas{position:absolute;top:0;left:0;image-rendering:pixelated;}

  /* ZOOM BAR */
  .zoom-bar{position:absolute;bottom:16px;right:16px;display:flex;align-items:center;
    gap:8px;background:rgba(10,12,15,.85);border:1px solid var(--border);border-radius:4px;
    padding:6px 12px;font-family:var(--mono);font-size:11px;color:var(--text-dim);
    backdrop-filter:blur(6px);}
  .zoom-bar button{background:none;border:none;color:var(--text-dim);cursor:pointer;
    font-size:16px;line-height:1;transition:color .15s;}
  .zoom-bar button:hover{color:var(--accent);}
  .zoom-val{color:var(--text);min-width:42px;text-align:center;
    font-family:var(--mono);font-size:11px;}

  /* LOADER */
  #loader{position:absolute;inset:0;display:none;align-items:center;
    justify-content:center;background:rgba(10,12,15,.8);font-family:var(--mono);
    font-size:12px;letter-spacing:3px;color:var(--accent);text-transform:uppercase;z-index:100;}
  #loader.visible{display:flex;}
  .spinner{width:20px;height:20px;border:2px solid var(--border);
    border-top-color:var(--accent);border-radius:50%;
    animation:spin .7s linear infinite;margin-right:12px;}
  @keyframes spin{to{transform:rotate(360deg);}}

  /* CRACK RESULTS */
  .crack-run-btn{width:100%;padding:9px;margin-top:4px;
    border:1px solid var(--accent2);background:rgba(255,68,68,.06);
    color:var(--accent2);font-family:var(--mono);font-size:11px;letter-spacing:2px;
    text-transform:uppercase;cursor:pointer;border-radius:3px;transition:all .2s;
    display:flex;align-items:center;justify-content:center;gap:8px;}
  .crack-run-btn:hover{background:rgba(255,68,68,.15);}
  .crack-run-btn:disabled{opacity:.4;cursor:not-allowed;}
  .crack-run-btn.running{border-color:var(--accent);color:var(--accent);background:rgba(0,229,255,.06);}
  .crack-results{background:rgba(0,0,0,.3);border:1px solid var(--border);
    border-radius:4px;overflow:hidden;display:none;}
  .crack-results.visible{display:block;}
  .crack-summary{padding:8px 10px;font-family:var(--mono);font-size:10px;
    border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:center;}
  .crack-summary .cnt{color:var(--accent2);font-size:14px;font-weight:bold;}
  .crack-summary .clr{color:var(--text-dim);cursor:pointer;padding:2px 6px;
    border:1px solid var(--border);border-radius:2px;font-size:9px;transition:all .15s;}
  .crack-summary .clr:hover{color:var(--accent);border-color:var(--accent);}
  .crack-list{max-height:200px;overflow-y:auto;}
  .crack-item{padding:7px 10px;border-bottom:1px solid rgba(30,38,48,.6);
    cursor:pointer;transition:background .1s;display:flex;gap:8px;align-items:flex-start;}
  .crack-item:hover{background:rgba(255,255,255,.03);}
  .crack-item:last-child{border-bottom:none;}
  .crack-item.selected{background:rgba(0,229,255,.06);}
  .crack-badge{width:20px;height:20px;border-radius:2px;flex-shrink:0;
    display:flex;align-items:center;justify-content:center;
    font-family:var(--mono);font-size:9px;font-weight:bold;color:#000;}
  .crack-badge.sev-low{background:#f5c542;}
  .crack-badge.sev-medium{background:#f58a00;}
  .crack-badge.sev-high{background:#ff3333;}
  .crack-item-info{flex:1;min-width:0;}
  .ci-main{font-family:var(--mono);font-size:10px;color:var(--text);line-height:1.5;}
  .ci-sub{font-family:var(--mono);font-size:9px;color:var(--text-dim);line-height:1.5;}

  /* CALIBRATION MODAL */
  #cal-modal{display:none;position:fixed;inset:0;background:rgba(0,0,0,.7);
    z-index:2000;align-items:center;justify-content:center;}
  #cal-modal.visible{display:flex;}
  #cal-modal .modal-box{background:var(--panel);border:1px solid var(--accent);
    border-radius:6px;padding:24px;width:280px;}
  #cal-modal h3{font-family:var(--mono);font-size:11px;letter-spacing:2px;
    color:var(--accent);text-transform:uppercase;margin-bottom:16px;}
  #cal-modal p{font-size:12px;color:var(--text-dim);margin-bottom:12px;line-height:1.5;}
  #cal-modal input[type=number]{width:100%;padding:8px;background:var(--bg);
    border:1px solid var(--border);color:var(--text);font-family:var(--mono);
    font-size:13px;border-radius:3px;outline:none;margin-bottom:14px;}
  #cal-modal input[type=number]:focus{border-color:var(--accent);}
  #cal-modal .modal-btns{display:flex;gap:8px;}
  #cal-modal .modal-btns button{flex:1;padding:8px;border-radius:3px;
    font-family:var(--mono);font-size:10px;letter-spacing:1px;cursor:pointer;transition:all .15s;}
  #cal-modal .modal-btns .ok{background:var(--accent);color:#000;border:none;}
  #cal-modal .modal-btns .ok:hover{opacity:.85;}
  #cal-modal .modal-btns .cancel{background:none;border:1px solid var(--border);color:var(--text-dim);}
  #cal-modal .modal-btns .cancel:hover{border-color:var(--accent2);color:var(--accent2);}


  /* ANNOTATION PANEL */
  #annotCanvas{position:absolute;top:0;left:0;image-rendering:pixelated;pointer-events:none;}
  #annotCanvas.active{pointer-events:auto;cursor:crosshair;}
  textarea.ann-textarea{width:100%;background:var(--bg);border:1px solid var(--border);
    color:var(--text);font-family:var(--mono);font-size:11px;border-radius:3px;
    padding:6px 8px;resize:vertical;outline:none;line-height:1.5;}
  textarea.ann-textarea:focus{border-color:var(--accent);}
  textarea.ann-textarea::placeholder{color:var(--text-dim);}
  .ann-item{background:rgba(0,0,0,.3);border:1px solid var(--border);border-radius:4px;
    padding:8px 10px;margin-top:6px;position:relative;}
  .ann-item.approved{border-left:3px solid #39ff14;}
  .ann-item.rejected{border-left:3px solid var(--accent2);}
  .ann-item .ann-header{display:flex;align-items:center;gap:6px;margin-bottom:4px;}
  .ann-badge{font-family:var(--mono);font-size:9px;font-weight:bold;letter-spacing:1px;
    padding:2px 6px;border-radius:2px;text-transform:uppercase;}
  .ann-badge.ok{background:rgba(57,255,20,.15);color:#39ff14;border:1px solid rgba(57,255,20,.3);}
  .ann-badge.nok{background:rgba(255,68,68,.15);color:var(--accent2);border:1px solid rgba(255,68,68,.3);}
  .ann-badge.none{background:rgba(255,255,255,.06);color:var(--text-dim);border:1px solid var(--border);}
  .ann-num{font-family:var(--mono);font-size:10px;color:var(--text-dim);}
  .ann-comment-text{font-size:11px;color:var(--text);line-height:1.5;margin-top:2px;word-break:break-word;}
  .ann-del{position:absolute;top:6px;right:8px;background:none;border:none;
    color:var(--text-dim);cursor:pointer;font-size:14px;line-height:1;padding:0;transition:color .15s;}
  .ann-del:hover{color:var(--accent2);}
  .ann-pts{font-family:var(--mono);font-size:9px;color:var(--text-dim);margin-top:2px;}
  .poly-hint{font-size:10px;color:var(--accent);font-family:var(--mono);
    padding:5px 8px;background:rgba(0,229,255,.05);border:1px solid rgba(0,229,255,.15);
    border-radius:3px;line-height:1.5;display:none;}
  .poly-hint.visible{display:block;}
  ::-webkit-scrollbar{width:4px;}
  ::-webkit-scrollbar-track{background:transparent;}
  ::-webkit-scrollbar-thumb{background:var(--border);border-radius:2px;}
</style>
</head>
<body>

<header>
  <div class="logo">XRAY-ANALYZE</div>
  <div class="sep"></div>
  <div class="subtitle">Keramische Plaat Inspectie</div>
  <div class="hdr-status">GEREED &mdash; <span id="hdr-status">GEEN AFBEELDING</span></div>
  <button class="hdr-btn report-btn" onclick="generateReport()" title="Genereer analyserapport">
    <svg viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
    Rapport
  </button>
  <button class="hdr-btn" id="export-btn" onclick="exportPNG()">
    <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
    Export PNG
  </button>
</header>

<aside>

  <!-- BESTAND -->
  <div>
    <div class="sec-title">Bestand</div>
    <div class="dropzone" id="dropzone">
      <input type="file" id="fileInput" accept=".tif,.tiff,image/*">
      <div class="dz-icon">&#128194;</div>
      <div class="dz-text"><strong>Sleep TIFF hier</strong><br>of klik om te openen<br><small>TIFF 8/16-bit &bull; PNG &bull; JPEG</small></div>
    </div>
    <div class="error-box" id="error-box"></div>
  </div>

  <!-- WEERGAVE -->
  <div>
    <div class="sec-title">Weergave modus</div>
    <div style="display:flex;flex-direction:column;gap:5px;">
      <button class="mode-btn active" data-mode="original" onclick="setMode('original')"><span class="dot"></span> Origineel</button>
      <button class="mode-btn" data-mode="pseudo" onclick="setMode('pseudo')"><span class="dot"></span> Pseudo kleur</button>
      <button class="mode-btn" data-mode="edge" onclick="setMode('edge')"><span class="dot"></span> Sobel randen</button>
      <button class="mode-btn" data-mode="canny" onclick="setMode('canny')"><span class="dot"></span> Canny randen</button>
      <button class="mode-btn" data-mode="edge2" onclick="setMode('edge2')"><span class="dot"></span> Sobel + drempel</button>
      <button class="mode-btn" data-mode="overlay" onclick="setMode('overlay')"><span class="dot"></span> Overlay op foto</button>
    </div>
  </div>

  <!-- VOORBEWERKING -->
  <div>
    <div class="sec-title">Voorbewerking</div>
    <div style="display:flex;flex-direction:column;gap:10px;">
      <label class="ctrl">
        <div class="lbl">Gaussische vervaging &sigma; <span id="val-blur">0</span></div>
        <input type="range" id="blur-sigma" min="0" max="10" value="0" step="0.5" oninput="document.getElementById('val-blur').textContent=this.value;updateFilter()">
      </label>
      <label class="ctrl">
        <div class="lbl">CLAHE <span id="clahe-status" style="color:var(--text-dim)">UIT</span></div>
        <div class="btn-group">
          <button class="btn" id="btn-clahe" onclick="toggleCLAHE()">AAN/UIT</button>
        </div>
      </label>
      <label class="ctrl" id="clahe-settings" style="display:none;">
        <div class="lbl">Clip limiet <span id="val-clip">3</span></div>
        <input type="range" id="clahe-clip" min="1" max="20" value="3" oninput="document.getElementById('val-clip').textContent=this.value;updateFilter()">
      </label>
      <label class="ctrl" id="clahe-tile-settings" style="display:none;">
        <div class="lbl">Tegels <span id="val-tiles">8</span>x<span id="val-tiles2">8</span></div>
        <input type="range" id="clahe-tiles" min="4" max="16" value="8" step="2" oninput="document.getElementById('val-tiles').textContent=this.value;document.getElementById('val-tiles2').textContent=this.value;updateFilter()">
      </label>
    </div>
  </div>

  <!-- BEELD FILTERS -->
  <div>
    <div class="sec-title">Beeld filters</div>
    <div style="display:flex;flex-direction:column;gap:10px;">
      <label class="ctrl">
        <div class="lbl">Helderheid <span id="val-brightness">100</span>%</div>
        <input type="range" id="brightness" min="0" max="300" value="100" oninput="updateFilter()">
      </label>
      <label class="ctrl">
        <div class="lbl">Contrast <span id="val-contrast">100</span>%</div>
        <input type="range" id="contrast" min="0" max="400" value="100" oninput="updateFilter()">
      </label>
      <label class="ctrl">
        <div class="lbl">Gamma <span id="val-gamma">1.0</span></div>
        <input type="range" id="gamma" min="10" max="300" value="100" oninput="updateFilter()">
      </label>
      <div class="btn-group">
        <button class="btn danger" id="btn-invert" onclick="toggleInvert()">Invert</button>
        <button class="btn success" id="btn-auto" onclick="autoOptimize()">Auto</button>
        <button class="btn" onclick="resetFilters()">Reset</button>
      </div>
      <div id="auto-info" class="small-info" style="display:none;"></div>
    </div>
  </div>

  <!-- PSEUDO KLEUR -->
  <div>
    <div class="sec-title">Pseudo kleur</div>
    <div class="btn-group">
      <button class="btn" id="cm-gray" onclick="setColormap('gray')">Grijs</button>
      <button class="btn active" id="cm-jet" onclick="setColormap('jet')">Jet</button>
      <button class="btn" id="cm-inferno" onclick="setColormap('inferno')">Inferno</button>
      <button class="btn" id="cm-viridis" onclick="setColormap('viridis')">Viridis</button>
      <button class="btn" id="cm-hot" onclick="setColormap('hot')">Heet</button>
    </div>
    <div style="margin-top:6px;font-size:9px;color:var(--text-dim);font-family:var(--mono);">
      Actief in 'Pseudo kleur' modus
    </div>
  </div>

  <!-- EDGE DETECTION -->
  <div>
    <div class="sec-title">Edge Detection</div>
    <div style="display:flex;flex-direction:column;gap:10px;">
      <label class="ctrl">
        <div class="lbl">Sobel drempel <span id="val-threshold">30</span></div>
        <input type="range" id="threshold" min="1" max="255" value="30" oninput="updateFilter()">
      </label>
      <label class="ctrl">
        <div class="lbl">Canny laag <span id="val-canny-lo">20</span></div>
        <input type="range" id="canny-lo" min="1" max="200" value="20" oninput="document.getElementById('val-canny-lo').textContent=this.value;updateFilter()">
      </label>
      <label class="ctrl">
        <div class="lbl">Canny hoog <span id="val-canny-hi">60</span></div>
        <input type="range" id="canny-hi" min="5" max="255" value="60" oninput="document.getElementById('val-canny-hi').textContent=this.value;updateFilter()">
      </label>
      <label class="ctrl">
        <div class="lbl">Overlay kleur</div>
        <div class="btn-group">
          <button class="btn success active" id="oc-green" onclick="setOverlayColor('green')">Groen</button>
          <button class="btn danger" id="oc-red" onclick="setOverlayColor('red')">Rood</button>
          <button class="btn" id="oc-cyan" onclick="setOverlayColor('cyan')">Cyaan</button>
        </div>
      </label>
    </div>
  </div>

  <!-- VERGROOTGLAS -->
  <div>
    <div class="sec-title">Vergrootglas</div>
    <div style="display:flex;flex-direction:column;gap:10px;">
      <div class="btn-group">
        <button class="btn active" id="btn-mag" onclick="toggleMagnifier()">AAN</button>
        <button class="btn" onclick="cycleMagSize()">Grootte:<span id="mag-size">220</span></button>
      </div>
      <label class="ctrl">
        <div class="lbl">Zoom <span id="val-magzoom">4</span>x</div>
        <input type="range" id="magzoom" min="2" max="12" value="4" oninput="document.getElementById('val-magzoom').textContent=this.value">
      </label>
    </div>
  </div>

  <!-- ROI SELECTIE -->
  <div>
    <div class="sec-title">ROI Selectie</div>
    <div style="display:flex;flex-direction:column;gap:8px;">
      <div style="font-size:11px;color:var(--text-dim);font-family:var(--mono);line-height:1.5;">
        Teken een rechthoek op het beeld om analyse te beperken tot dat gebied.
      </div>
      <div class="btn-group">
        <button class="btn" id="btn-roi" onclick="toggleROIMode()">Teken ROI</button>
        <button class="btn danger" onclick="clearROI()">Wis</button>
      </div>
      <div id="roi-info" style="font-family:var(--mono);font-size:10px;color:var(--text-dim);display:none;"></div>
    </div>
  </div>

  <!-- KALIBRATIE -->
  <div>
    <div class="sec-title">DPI Kalibratie</div>
    <div style="display:flex;flex-direction:column;gap:8px;">
      <div style="font-size:11px;color:var(--text-dim);font-family:var(--mono);line-height:1.5;">
        Klik twee punten op het beeld met bekende afstand om pixels naar mm te kalibreren.
      </div>
      <div class="btn-group">
        <button class="btn" id="btn-cal" onclick="toggleCalMode()">Stel in</button>
        <button class="btn danger" onclick="clearCalibration()">Wis</button>
      </div>
      <div id="cal-info" style="font-family:var(--mono);font-size:10px;color:var(--text-dim);display:none;"></div>
    </div>
  </div>

  <!-- INFO -->
  <div>
    <div class="sec-title">Info</div>
    <div class="info-box">
      Afmeting: <span class="val" id="info-size">&#8212;</span><br>
      Cursor: <span class="val" id="info-xy">&#8212;</span><br>
      Pixel: <span class="val" id="info-px">&#8212;</span><br>
      Bit-diepte: <span class="val" id="info-bits">&#8212;</span><br>
      Bestand: <span class="val" id="info-file">&#8212;</span>
    </div>
    <div style="margin-top:8px;font-size:9px;color:var(--text-dim);font-family:var(--mono);line-height:1.6;">
      1-6 modus | M vergroot | +/- zoom | F passend | R ROI | C kal | P poly
    </div>
  </div>

  <!-- SCHEURDETECTIE -->
  <div id="crack-section">
    <div class="sec-title">Scheurdetectie</div>
    <div style="display:flex;flex-direction:column;gap:10px;">
      <label class="ctrl">
        <div class="lbl">Min. lengte <span id="val-minlen">40</span> px</div>
        <input type="range" id="crack-minlen" min="5" max="300" value="40">
      </label>
      <label class="ctrl">
        <div class="lbl">Min. aspect ratio <span id="val-minaspect">3.0</span></div>
        <input type="range" id="crack-minaspect" min="10" max="100" value="30">
      </label>
      <label class="ctrl">
        <div class="lbl">Doos padding <span id="val-boxpad">4</span> px</div>
        <input type="range" id="crack-boxpad" min="1" max="20" value="4">
      </label>
      <button class="crack-run-btn" id="crack-run-btn" onclick="detectCracks()">
        <span id="crack-btn-label">&#9654; Analyseer scheuren</span>
      </button>
    </div>
    <div class="crack-results" id="crack-results" style="margin-top:10px;">
      <div class="crack-summary">
        <div><span class="cnt" id="crack-count">0</span> <span style="color:var(--text-dim);font-size:10px;">kandidaten</span></div>
        <div class="clr" onclick="clearCracks()">Wis</div>
      </div>
      <div class="crack-list" id="crack-list"></div>
    </div>
    <div style="margin-top:6px;font-size:9px;color:var(--text-dim);font-family:var(--mono);line-height:1.6;">
      <span style="color:#f5c542">&#9632;</span> kort &nbsp;
      <span style="color:#f58a00">&#9632;</span> middel &nbsp;
      <span style="color:#ff3333">&#9632;</span> lang
    </div>
  </div>


  <!-- ANNOTATIES -->
  <div>
    <div class="sec-title">Annotaties</div>
    <div style="display:flex;flex-direction:column;gap:8px;">
      <div style="font-size:11px;color:var(--text-dim);font-family:var(--mono);line-height:1.5;">
        Klik punten op beeld. Dubbelklik om te sluiten.
      </div>
      <div class="poly-hint" id="poly-hint">
        Punten: <span id="poly-pt-count">0</span><br>
        Dubbelklik = sluiten &nbsp;|&nbsp; Esc = annuleer
      </div>
      <div class="btn-group">
        <button class="btn" id="btn-poly" onclick="togglePolyMode()">&#9998; Teken</button>
        <button class="btn danger" id="btn-poly-done" onclick="finishAnnotation()" style="display:none;">&#10003; Klaar</button>
        <button class="btn" id="btn-poly-cancel" onclick="cancelPoly()" style="display:none;">&#10005;</button>
      </div>
      <div style="font-size:10px;color:var(--text-dim);font-family:var(--mono);margin-top:4px;">Oordeel</div>
      <div class="btn-group">
        <button class="btn success" id="ann-approve" onclick="setAnnStatus('goedgekeurd')">&#10003; Goed</button>
        <button class="btn danger" id="ann-reject" onclick="setAnnStatus('afgekeurd')">&#10005; Afkeur</button>
        <button class="btn" id="ann-neutral" onclick="setAnnStatus(null)" style="min-width:40px;">&#8212;</button>
      </div>
      <label class="ctrl">
        <div class="lbl">Opmerking</div>
        <textarea class="ann-textarea" id="ann-comment" rows="2" placeholder="Optionele toelichting..."></textarea>
      </label>
      <div id="ann-list"></div>
      <button class="btn danger" style="margin-top:2px;" onclick="clearAnnotations()">Wis alles</button>
    </div>
  </div>

</aside>

<main id="main">
  <div id="drop-overlay">
    <div class="big-icon">&#11041;</div>
    <div class="msg">Sleep een rontgenfoto hierheen</div>
  </div>
  <div id="canvas-wrapper">
    <canvas id="mainCanvas"></canvas>
    <canvas id="overlayCanvas"></canvas>
    <canvas id="uiCanvas"></canvas>
    <canvas id="annotCanvas"></canvas>
  </div>
  <div id="loader"><div class="spinner"></div>Laden&hellip;</div>
  <div class="zoom-bar">
    <button onclick="changeZoom(-0.1)">&#8722;</button>
    <div class="zoom-val" id="zoom-label">100%</div>
    <button onclick="changeZoom(0.1)">+</button>
    <button onclick="resetZoom()" style="font-size:11px;font-family:var(--mono)">FIT</button>
  </div>
</main>

<div id="magnifier"><canvas id="magCanvas"></canvas></div>

<!-- CALIBRATION MODAL -->
<div id="cal-modal">
  <div class="modal-box">
    <h3>Kalibratie instellen</h3>
    <p>Lijn getekend: <strong id="cal-px-dist">0</strong> pixels.<br>Voer de werkelijke afstand in:</p>
    <input type="number" id="cal-mm-input" placeholder="bijv. 10" min="0.01" step="0.01">
    <div class="modal-btns">
      <button class="cancel" onclick="closeCalModal()">Annuleer</button>
      <button class="ok" onclick="confirmCalibration()">Bevestig</button>
    </div>
  </div>
</div>

<script>
class TiffDecoder {
  constructor(buffer) {
    this.buf   = new DataView(buffer);
    this.bytes = new Uint8Array(buffer);
    const sig  = this.buf.getUint16(0, false);
    this.le    = sig === 0x4949;
    if (sig !== 0x4949 && sig !== 0x4D4D) throw new Error('Geen geldig TIFF bestand (ongeldige byte-order)');
    if (this.r16(2) !== 42) throw new Error('Geen geldig TIFF bestand (magic number)');
  }

  r16(o) { return this.buf.getUint16(o, this.le); }
  r32(o) { return this.buf.getUint32(o, this.le); }

  readIFD(offset) {
    const count = this.r16(offset);
    const tags  = {};
    for (let i = 0; i < count; i++) {
      const o = offset + 2 + i * 12;
      tags[this.r16(o)] = { type: this.r16(o+2), cnt: this.r32(o+4), rawOff: o+8 };
    }
    return tags;
  }

  tagValues(t) {
    if (!t) return null;
    const typeSizes = [0,1,1,2,4,8,1,1,2,4,8,4,8];
    const sz = typeSizes[t.type] || 1;
    let off = t.rawOff;
    if (t.cnt * sz > 4) off = this.r32(t.rawOff);
    const vals = [];
    for (let i = 0; i < t.cnt; i++) {
      const o = off + i * sz;
      if      (t.type === 3) vals.push(this.r16(o));
      else if (t.type === 4) vals.push(this.r32(o));
      else if (t.type === 5) vals.push(this.r32(o) / (this.r32(o+4) || 1));
      else                   vals.push(this.bytes[o]);
    }
    return vals;
  }

  tv1(tag) { const v = this.tagValues(tag); return v ? v[0] : undefined; }

  // Walk all IFDs and return the one with the largest pixel area
  allIFDs() {
    const ifds = [];
    let off = this.r32(4);
    while (off !== 0 && ifds.length < 20) {
      const count = this.r16(off);
      ifds.push(off);
      off = this.r32(off + 2 + count * 12);
    }
    return ifds;
  }

  decode() {
    // Pick the IFD with the largest resolution (skip thumbnails)
    const ifdOffsets = this.allIFDs();
    let bestOff = ifdOffsets[0];
    let bestArea = 0;
    for (const off of ifdOffsets) {
      const t = this.readIFD(off);
      const w = this.tv1(t[256]) || 0;
      const h = this.tv1(t[257]) || 0;
      if (w * h > bestArea) { bestArea = w * h; bestOff = off; }
    }
    const ifdOff = bestOff;
    const tags   = this.readIFD(ifdOff);

    const W     = this.tv1(tags[256]);
    const H     = this.tv1(tags[257]);
    const bps   = this.tv1(tags[258]) ?? 8;
    const comp  = this.tv1(tags[259]) ?? 1;
    const photo = this.tv1(tags[262]) ?? 1;
    const spp   = this.tv1(tags[277]) ?? 1;

    const offsets  = this.tagValues(tags[273]) ?? [0];
    const byteCnts = this.tagValues(tags[279]) ?? [W * H * spp * (bps >> 3)];

    // assemble raw data
    let raw;
    if (comp === 1) {
      const total = byteCnts.reduce((a,b) => a+b, 0);
      raw = new Uint8Array(total);
      let pos = 0;
      for (let s = 0; s < offsets.length; s++) {
        raw.set(this.bytes.subarray(offsets[s], offsets[s] + byteCnts[s]), pos);
        pos += byteCnts[s];
      }
    } else if (comp === 5) {
      const parts = offsets.map((o, s) => this.lzwDecode(this.bytes.subarray(o, o + byteCnts[s])));
      const total = parts.reduce((a,b) => a+b.length, 0);
      raw = new Uint8Array(total);
      let pos = 0;
      for (const p of parts) { raw.set(p, pos); pos += p.length; }
    } else {
      throw new Error(`Compressie type ${comp} wordt niet ondersteund. Exporteer als ongecomprimeerde TIFF.`);
    }

    // to RGBA8
    const rgba = new Uint8ClampedArray(W * H * 4);
    const max  = (1 << bps) - 1;

    const get16 = (i) => this.le
      ? (raw[i*2+1] << 8 | raw[i*2])
      : (raw[i*2]   << 8 | raw[i*2+1]);

    if (spp === 1) {
      for (let i = 0; i < W * H; i++) {
        let v = bps === 16 ? get16(i) : raw[i];
        let g = Math.round(v / max * 255);
        if (photo === 0) g = 255 - g;
        rgba[i*4] = rgba[i*4+1] = rgba[i*4+2] = g;
        rgba[i*4+3] = 255;
      }
    } else {
      for (let i = 0; i < W * H; i++) {
        for (let c = 0; c < 3; c++) {
          const idx = i * spp + c;
          const v   = bps === 16 ? get16(idx) : raw[idx];
          rgba[i*4+c] = Math.round(v / max * 255);
        }
        rgba[i*4+3] = 255;
      }
    }

    const totalIFDs = ifdOffsets.length;
    return { width: W, height: H, rgba, bitsPerSample: bps, totalIFDs, ifdOff: bestOff };
  }

  // LZW decoder (TIFF flavour, MSB-first, clear=256, eoi=257)
  lzwDecode(input) {
    const out = [];
    let bitBuf = 0, bits = 0, codeLen = 9, pos = 0;
    const table = [];

    const reset = () => {
      table.length = 0;
      for (let i = 0; i < 256; i++) table[i] = new Uint8Array([i]);
      table[256] = null; table[257] = null;
      codeLen = 9;
    };
    reset();

    const readCode = () => {
      while (bits < codeLen) {
        if (pos >= input.length) return 257;
        bitBuf = (bitBuf << 8) | input[pos++];
        bits  += 8;
      }
      bits -= codeLen;
      return (bitBuf >> bits) & ((1 << codeLen) - 1);
    };

    let prev = null;
    while (true) {
      const code = readCode();
      if (code === 257) break;
      if (code === 256) { reset(); prev = null; continue; }

      let entry;
      if (table[code] != null) {
        entry = table[code];
      } else {
        // code not yet in table
        entry = new Uint8Array([...prev, prev[0]]);
      }

      for (const b of entry) out.push(b);

      if (prev !== null) {
        const newEntry = new Uint8Array([...prev, entry[0]]);
        table.push(newEntry);
        if (table.length >= (1 << codeLen) - 1 && codeLen < 12) codeLen++;
      }
      prev = entry;
    }
    return new Uint8Array(out);
  }
}


// ============================================================
//  APP STATE
// ============================================================
let originalImageData = null;
let processedImageData = null;
let edgeImageData      = null;
let cannyImageData     = null;
let currentMode   = 'original';
let invertOn      = false;
let overlayColor  = 'green';
let magEnabled    = true;
let magSize       = 220;
const magSizes    = [160, 220, 300];
let magSizeIdx    = 1;
let zoom          = 1.0;
let claheEnabled  = false;
let currentColormap = 'jet';

// ROI
let roiMode   = false;
let roiRect   = null;  // {x,y,w,h} in canvas px
let roiStart  = null;

// Calibration
let calMode   = false;
let calPoints = [];    // [{x,y}]
let pxPerMm   = null;
let calPxDist = 0;

const canvas   = document.getElementById('mainCanvas');
const ctx      = canvas.getContext('2d');
const overlayCv  = document.getElementById('overlayCanvas');
const overlayCtx = overlayCv.getContext('2d');
const uiCv     = document.getElementById('uiCanvas');
const uiCtx    = uiCv.getContext('2d');
const magDiv   = document.getElementById('magnifier');
const magCv    = document.getElementById('magCanvas');
const magCtx   = magCv.getContext('2d');
const wrapper  = document.getElementById('canvas-wrapper');
const mainEl   = document.getElementById('main');

// ── FILE LOADING ──────────────────────────────
document.getElementById('fileInput').addEventListener('change', e => { if (e.target.files[0]) loadFile(e.target.files[0]); });
const dz = document.getElementById('dropzone');
mainEl.addEventListener('dragover', e => e.preventDefault());
mainEl.addEventListener('drop', e => { e.preventDefault(); if (e.dataTransfer.files[0]) loadFile(e.dataTransfer.files[0]); });
dz.addEventListener('dragover', e => { e.preventDefault(); dz.classList.add('dragover'); });
dz.addEventListener('dragleave', () => dz.classList.remove('dragover'));
dz.addEventListener('drop', e => { e.preventDefault(); dz.classList.remove('dragover'); if (e.dataTransfer.files[0]) loadFile(e.dataTransfer.files[0]); });

function showError(msg) { const b = document.getElementById('error-box'); b.textContent = 'Fout: ' + msg; b.style.display = 'block'; }
function clearError()   { document.getElementById('error-box').style.display = 'none'; }

function loadFile(file) {
  clearError(); showLoader(true);
  const name = file.name;
  document.getElementById('info-file').textContent = name.length > 24 ? name.slice(0,22) + '...' : name;
  const ext = name.split('.').pop().toLowerCase();
  const reader = new FileReader();
  if (ext === 'tif' || ext === 'tiff') {
    reader.onload = e => {
      try {
        const dec = new TiffDecoder(e.target.result);
        const info = dec.decode();
        canvas.width = info.width; canvas.height = info.height;
        const id = ctx.createImageData(info.width, info.height);
        id.data.set(info.rgba); ctx.putImageData(id, 0, 0);
        originalImageData = ctx.getImageData(0, 0, info.width, info.height);
        document.getElementById('info-bits').textContent = info.bitsPerSample + '-bit' +
          (info.totalIFDs > 1 ? ' (' + info.totalIFDs + ' lagen)' : '');
        onImageLoaded();
      } catch(err) { showLoader(false); showError(err.message); }
    };
    reader.readAsArrayBuffer(file);
  } else {
    reader.onload = e => {
      const img = new Image();
      img.onload = () => {
        canvas.width = img.naturalWidth; canvas.height = img.naturalHeight;
        ctx.drawImage(img, 0, 0);
        originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        document.getElementById('info-bits').textContent = '8-bit';
        onImageLoaded();
      };
      img.onerror = () => { showLoader(false); showError('Kan afbeelding niet laden.'); };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  }
}

function onImageLoaded() {
  clearCracks(); clearROI(); clearAnnotations();
  annotCv.width = canvas.width; annotCv.height = canvas.height;
  overlayCv.width = uiCv.width  = canvas.width;
  overlayCv.height = uiCv.height = canvas.height;
  document.getElementById('drop-overlay').style.display = 'none';
  document.getElementById('info-size').textContent = canvas.width + ' x ' + canvas.height + ' px';
  document.getElementById('hdr-status').textContent = canvas.width + 'x' + canvas.height;
  fitToScreen(); updateFilter(); showLoader(false);
}

// ── GAUSSIAN BLUR ──────────────────────────────
function gaussianKernel(sigma) {
  if (sigma <= 0) return null;
  const r    = Math.ceil(3 * sigma);
  const size = 2 * r + 1;
  const k    = new Float32Array(size);
  let sum = 0;
  for (let i = 0; i < size; i++) {
    const x = i - r;
    k[i] = Math.exp(-x * x / (2 * sigma * sigma));
    sum += k[i];
  }
  for (let i = 0; i < size; i++) k[i] /= sum;
  return { k, r };
}

function gaussianBlur(gray, w, h, sigma) {
  const g = gaussianKernel(sigma);
  if (!g) return gray;
  const { k, r } = g;
  const tmp = new Float32Array(w * h);
  const out = new Float32Array(w * h);
  // Horizontal pass
  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      let v = 0;
      for (let i = -r; i <= r; i++) {
        const xi = Math.max(0, Math.min(w - 1, x + i));
        v += gray[y * w + xi] * k[i + r];
      }
      tmp[y * w + x] = v;
    }
  }
  // Vertical pass
  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      let v = 0;
      for (let i = -r; i <= r; i++) {
        const yi = Math.max(0, Math.min(h - 1, y + i));
        v += tmp[yi * w + x] * k[i + r];
      }
      out[y * w + x] = v;
    }
  }
  return out;
}

// ── CLAHE ─────────────────────────────────────
function applyCLAHE(gray, w, h, clipLimit, tilesX, tilesY) {
  const tileW = Math.ceil(w / tilesX);
  const tileH = Math.ceil(h / tilesY);
  const tileArea = tileW * tileH;
  const clip = Math.max(1, Math.round(clipLimit * tileArea / 256));

  // Compute CDF for each tile
  const cdfs = [];
  for (let ty = 0; ty < tilesY; ty++) {
    cdfs.push([]);
    for (let tx = 0; tx < tilesX; tx++) {
      const hist = new Int32Array(256);
      const x0 = tx * tileW, y0 = ty * tileH;
      const x1 = Math.min(x0 + tileW, w), y1 = Math.min(y0 + tileH, h);
      for (let y = y0; y < y1; y++)
        for (let x = x0; x < x1; x++)
          hist[Math.min(255, Math.round(gray[y * w + x]))]++;
      // Clip
      let excess = 0;
      for (let i = 0; i < 256; i++) {
        if (hist[i] > clip) { excess += hist[i] - clip; hist[i] = clip; }
      }
      const add = Math.floor(excess / 256);
      for (let i = 0; i < 256; i++) hist[i] += add;
      // CDF
      const cdf = new Float32Array(256);
      cdf[0] = hist[0];
      for (let i = 1; i < 256; i++) cdf[i] = cdf[i - 1] + hist[i];
      const cdfMin = cdf.find(v => v > 0) || 1;
      const total  = (x1 - x0) * (y1 - y0);
      for (let i = 0; i < 256; i++) cdf[i] = Math.round((cdf[i] - cdfMin) / Math.max(1, total - cdfMin) * 255);
      cdfs[ty].push(cdf);
    }
  }

  // Bilinear interpolation
  const out = new Float32Array(w * h);
  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      const v = Math.min(255, Math.round(gray[y * w + x]));
      // Tile center coordinates
      const txf = (x - tileW / 2) / tileW;
      const tyf = (y - tileH / 2) / tileH;
      const tx0 = Math.max(0, Math.floor(txf));
      const tx1 = Math.min(tilesX - 1, tx0 + 1);
      const ty0 = Math.max(0, Math.floor(tyf));
      const ty1 = Math.min(tilesY - 1, ty0 + 1);
      const xfrac = Math.max(0, Math.min(1, txf - tx0));
      const yfrac = Math.max(0, Math.min(1, tyf - ty0));
      const c00 = cdfs[ty0][tx0][v], c10 = cdfs[ty0][tx1][v];
      const c01 = cdfs[ty1][tx0][v], c11 = cdfs[ty1][tx1][v];
      out[y * w + x] =
        c00 * (1 - xfrac) * (1 - yfrac) +
        c10 * xfrac       * (1 - yfrac) +
        c01 * (1 - xfrac) * yfrac       +
        c11 * xfrac       * yfrac;
    }
  }
  return out;
}

// ── CANNY EDGE DETECTION ──────────────────────
function canny(gray, w, h, lowT, highT) {
  // 1. Sobel gradients + direction
  const mag = new Float32Array(w * h);
  const dir = new Float32Array(w * h);
  for (let y = 1; y < h - 1; y++) {
    for (let x = 1; x < w - 1; x++) {
      const p = (r, c) => gray[r * w + c];
      const gx = -p(y-1,x-1) + p(y-1,x+1) - 2*p(y,x-1) + 2*p(y,x+1) - p(y+1,x-1) + p(y+1,x+1);
      const gy = -p(y-1,x-1) - 2*p(y-1,x) - p(y-1,x+1) + p(y+1,x-1) + 2*p(y+1,x) + p(y+1,x+1);
      mag[y * w + x] = Math.sqrt(gx * gx + gy * gy);
      dir[y * w + x] = Math.atan2(gy, gx);
    }
  }
  // Normalize mag to 0-255
  let maxM = 0;
  for (let i = 0; i < mag.length; i++) if (mag[i] > maxM) maxM = mag[i];
  if (maxM > 0) for (let i = 0; i < mag.length; i++) mag[i] = mag[i] / maxM * 255;

  // 2. Non-maximum suppression
  const nms = new Float32Array(w * h);
  for (let y = 1; y < h - 1; y++) {
    for (let x = 1; x < w - 1; x++) {
      const idx = y * w + x;
      const angle = ((dir[idx] * 180 / Math.PI) + 180) % 180;
      let n1, n2;
      if      (angle < 22.5 || angle >= 157.5)  { n1 = mag[y*w+x-1];     n2 = mag[y*w+x+1]; }
      else if (angle < 67.5)                     { n1 = mag[(y-1)*w+x+1]; n2 = mag[(y+1)*w+x-1]; }
      else if (angle < 112.5)                    { n1 = mag[(y-1)*w+x];   n2 = mag[(y+1)*w+x]; }
      else                                       { n1 = mag[(y-1)*w+x-1]; n2 = mag[(y+1)*w+x+1]; }
      nms[idx] = (mag[idx] >= n1 && mag[idx] >= n2) ? mag[idx] : 0;
    }
  }

  // 3. Double threshold + hysteresis
  const out  = new Uint8Array(w * h);
  const STRONG = 255, WEAK = 128;
  for (let i = 0; i < nms.length; i++) {
    if      (nms[i] >= highT) out[i] = STRONG;
    else if (nms[i] >= lowT)  out[i] = WEAK;
  }
  // Hysteresis: connect weak to strong (4-pass BFS)
  let changed = true;
  while (changed) {
    changed = false;
    for (let y = 1; y < h - 1; y++) {
      for (let x = 1; x < w - 1; x++) {
        const idx = y * w + x;
        if (out[idx] !== WEAK) continue;
        const neighbors = [
          out[(y-1)*w+(x-1)], out[(y-1)*w+x], out[(y-1)*w+(x+1)],
          out[y*w+(x-1)],                      out[y*w+(x+1)],
          out[(y+1)*w+(x-1)], out[(y+1)*w+x], out[(y+1)*w+(x+1)]
        ];
        if (neighbors.some(v => v === STRONG)) { out[idx] = STRONG; changed = true; }
      }
    }
  }
  for (let i = 0; i < out.length; i++) if (out[i] === WEAK) out[i] = 0;

  const rgba = new Uint8ClampedArray(w * h * 4);
  for (let i = 0; i < w * h; i++) {
    rgba[i*4] = rgba[i*4+1] = rgba[i*4+2] = out[i]; rgba[i*4+3] = 255;
  }
  return new ImageData(rgba, w, h);
}

// ── PSEUDO COLOR LUTs ─────────────────────────
const COLORMAPS = (() => {
  // Build 256-entry [r,g,b] LUTs
  const maps = {};
  const lerp = (a, b, t) => a + (b - a) * t;

  // JET
  maps.jet = new Array(256).fill(0).map((_, i) => {
    const x = i / 255;
    const r = Math.round(255 * Math.max(0, Math.min(1, 1.5 - Math.abs(4*x - 3))));
    const g = Math.round(255 * Math.max(0, Math.min(1, 1.5 - Math.abs(4*x - 2))));
    const b = Math.round(255 * Math.max(0, Math.min(1, 1.5 - Math.abs(4*x - 1))));
    return [r, g, b];
  });

  // INFERNO (sampled from matplotlib)
  const infernoCtrl = [[0,0,4],[40,11,84],[101,21,110],[159,42,99],[212,72,66],[245,125,21],[252,192,81],[252,255,164]];
  maps.inferno = new Array(256).fill(0).map((_, i) => {
    const x  = i / 255 * (infernoCtrl.length - 1);
    const lo = Math.floor(x), hi = Math.min(infernoCtrl.length - 1, lo + 1);
    const t  = x - lo;
    return infernoCtrl[lo].map((v, c) => Math.round(lerp(v, infernoCtrl[hi][c], t)));
  });

  // VIRIDIS
  const viridisCtrl = [[68,1,84],[72,40,120],[62,83,161],[49,104,142],[38,130,142],[31,158,137],[74,194,109],[159,218,58],[253,231,37]];
  maps.viridis = new Array(256).fill(0).map((_, i) => {
    const x  = i / 255 * (viridisCtrl.length - 1);
    const lo = Math.floor(x), hi = Math.min(viridisCtrl.length - 1, lo + 1);
    const t  = x - lo;
    return viridisCtrl[lo].map((v, c) => Math.round(lerp(v, viridisCtrl[hi][c], t)));
  });

  // HOT
  maps.hot = new Array(256).fill(0).map((_, i) => {
    const x = i / 255;
    return [
      Math.round(255 * Math.min(1, x * 3)),
      Math.round(255 * Math.max(0, Math.min(1, x * 3 - 1))),
      Math.round(255 * Math.max(0, x * 3 - 2))
    ];
  });

  // GRAY (passthrough)
  maps.gray = new Array(256).fill(0).map((_, i) => [i, i, i]);

  return maps;
})();

function applyColormap(grayData, w, h, mapName) {
  const lut = COLORMAPS[mapName] || COLORMAPS.jet;
  const out  = new Uint8ClampedArray(w * h * 4);
  const src  = grayData.data;
  for (let i = 0; i < w * h; i++) {
    const g  = src[i * 4];
    out[i*4]   = lut[g][0];
    out[i*4+1] = lut[g][1];
    out[i*4+2] = lut[g][2];
    out[i*4+3] = 255;
  }
  return new ImageData(out, w, h);
}

// ── PROCESSING PIPELINE ──────────────────────
function updateFilter() {
  if (!originalImageData) return;

  const brightness = parseFloat(document.getElementById('brightness').value) / 100;
  const contrast   = parseFloat(document.getElementById('contrast').value) / 100;
  const gammaIn    = parseFloat(document.getElementById('gamma').value) / 100;
  const threshold  = parseInt(document.getElementById('threshold').value);
  const blurSigma  = parseFloat(document.getElementById('blur-sigma').value);
  const cannyLo    = parseInt(document.getElementById('canny-lo').value);
  const cannyHi    = parseInt(document.getElementById('canny-hi').value);
  const clipLimit  = parseInt(document.getElementById('clahe-clip').value);
  const tileN      = parseInt(document.getElementById('clahe-tiles').value);

  document.getElementById('val-brightness').textContent = document.getElementById('brightness').value;
  document.getElementById('val-contrast').textContent   = document.getElementById('contrast').value;
  document.getElementById('val-gamma').textContent      = gammaIn.toFixed(1);
  document.getElementById('val-threshold').textContent  = threshold;

  const src = originalImageData.data;
  const w   = originalImageData.width;
  const h   = originalImageData.height;
  const proc = new Uint8ClampedArray(src.length);

  // LUT: gamma → brightness → contrast → invert
  const lut = new Uint8ClampedArray(256);
  for (let i = 0; i < 256; i++) {
    let v = i / 255;
    v = Math.pow(v, 1 / gammaIn);
    v *= brightness;
    v = (v - 0.5) * contrast + 0.5;
    v = Math.max(0, Math.min(1, v));
    if (invertOn) v = 1 - v;
    lut[i] = Math.round(v * 255);
  }
  for (let i = 0; i < src.length; i += 4) {
    proc[i]   = lut[src[i]];
    proc[i+1] = lut[src[i+1]];
    proc[i+2] = lut[src[i+2]];
    proc[i+3] = src[i+3];
  }
  processedImageData = new ImageData(proc, w, h);

  // Grayscale
  let gray = new Float32Array(w * h);
  for (let i = 0; i < w * h; i++)
    gray[i] = 0.299 * proc[i*4] + 0.587 * proc[i*4+1] + 0.114 * proc[i*4+2];

  // Gaussian blur
  if (blurSigma > 0) gray = gaussianBlur(gray, w, h, blurSigma);

  // CLAHE
  if (claheEnabled) gray = applyCLAHE(gray, w, h, clipLimit, tileN, tileN);

  // Sobel
  const edgeG = new Float32Array(w * h);
  for (let y = 1; y < h - 1; y++) {
    for (let x = 1; x < w - 1; x++) {
      const p  = (r, c) => gray[r * w + c];
      const gx = -p(y-1,x-1)+p(y-1,x+1)-2*p(y,x-1)+2*p(y,x+1)-p(y+1,x-1)+p(y+1,x+1);
      const gy = -p(y-1,x-1)-2*p(y-1,x)-p(y-1,x+1)+p(y+1,x-1)+2*p(y+1,x)+p(y+1,x+1);
      edgeG[y * w + x] = Math.sqrt(gx*gx + gy*gy);
    }
  }
  let maxE = 0;
  for (let i = 0; i < edgeG.length; i++) if (edgeG[i] > maxE) maxE = edgeG[i];
  if (maxE === 0) maxE = 1;
  const ed = new Uint8ClampedArray(w * h * 4);
  for (let i = 0; i < w * h; i++) {
    const v = Math.round(edgeG[i] / maxE * 255);
    ed[i*4] = ed[i*4+1] = ed[i*4+2] = v; ed[i*4+3] = 255;
  }
  edgeImageData = new ImageData(ed, w, h);

  // Canny
  cannyImageData = canny(gray, w, h, cannyLo, cannyHi);

  renderMode();
}

function renderMode() {
  if (!originalImageData) return;
  const w = canvas.width, h = canvas.height;
  const thr = parseInt(document.getElementById('threshold').value);

  if (currentMode === 'original') {
    ctx.putImageData(processedImageData, 0, 0);

  } else if (currentMode === 'pseudo') {
    // Convert processedImageData to grayscale then apply colormap
    const src = processedImageData.data;
    const grayID = new ImageData(w, h);
    for (let i = 0; i < w * h; i++) {
      const g = Math.round(0.299*src[i*4] + 0.587*src[i*4+1] + 0.114*src[i*4+2]);
      grayID.data[i*4] = grayID.data[i*4+1] = grayID.data[i*4+2] = g;
      grayID.data[i*4+3] = 255;
    }
    ctx.putImageData(applyColormap(grayID, w, h, currentColormap), 0, 0);

  } else if (currentMode === 'edge') {
    ctx.putImageData(edgeImageData, 0, 0);

  } else if (currentMode === 'canny') {
    ctx.putImageData(cannyImageData, 0, 0);

  } else if (currentMode === 'edge2') {
    const s = edgeImageData.data;
    const b = new Uint8ClampedArray(s.length);
    for (let i = 0; i < s.length; i += 4) {
      const v = s[i] > thr ? 255 : 0;
      b[i] = b[i+1] = b[i+2] = v; b[i+3] = 255;
    }
    ctx.putImageData(new ImageData(b, w, h), 0, 0);

  } else if (currentMode === 'overlay') {
    ctx.putImageData(processedImageData, 0, 0);
    const s  = edgeImageData.data;
    const ov = ctx.createImageData(w, h);
    const od = ov.data;
    const [or, og, ob] = overlayColor === 'red' ? [255,0,0] : overlayColor === 'cyan' ? [0,220,255] : [0,255,60];
    for (let i = 0; i < s.length; i += 4) {
      if (s[i] > thr) { od[i]=or; od[i+1]=og; od[i+2]=ob; od[i+3]=Math.min(255,s[i]*2); }
    }
    ctx.putImageData(ov, 0, 0);
  }

  // Redraw crack boxes on top
  if (cracksFound.length) drawCrackBoxes(cracksFound);
  drawUI();
}

// ── UI CONTROLS ──────────────────────────────
function setMode(m) {
  currentMode = m;
  document.querySelectorAll('.mode-btn').forEach(b => b.classList.toggle('active', b.dataset.mode === m));
  renderMode();
}
function toggleInvert() {
  invertOn = !invertOn;
  document.getElementById('btn-invert').classList.toggle('active', invertOn);
  updateFilter();
}
function setOverlayColor(c) {
  overlayColor = c;
  ['green','red','cyan'].forEach(x => document.getElementById('oc-'+x).classList.toggle('active', x===c));
  renderMode();
}
function setColormap(c) {
  currentColormap = c;
  ['gray','jet','inferno','viridis','hot'].forEach(x => document.getElementById('cm-'+x).classList.toggle('active', x===c));
  renderMode();
}
function toggleCLAHE() {
  claheEnabled = !claheEnabled;
  document.getElementById('btn-clahe').classList.toggle('active', claheEnabled);
  document.getElementById('clahe-status').textContent = claheEnabled ? 'AAN' : 'UIT';
  document.getElementById('clahe-status').style.color = claheEnabled ? 'var(--accent3)' : 'var(--text-dim)';
  document.getElementById('clahe-settings').style.display = claheEnabled ? '' : 'none';
  document.getElementById('clahe-tile-settings').style.display = claheEnabled ? '' : 'none';
  updateFilter();
}
function resetFilters() {
  document.getElementById('brightness').value = 100;
  document.getElementById('contrast').value   = 100;
  document.getElementById('gamma').value       = 100;
  document.getElementById('threshold').value   = 30;
  document.getElementById('blur-sigma').value  = 0;
  document.getElementById('val-blur').textContent = '0';
  invertOn = false;
  document.getElementById('btn-invert').classList.remove('active');
  document.getElementById('auto-info').style.display = 'none';
  updateFilter();
}

// ── AUTO OPTIMIZE ─────────────────────────────
function autoOptimize() {
  if (!originalImageData) return;
  const src = originalImageData.data;
  const n   = originalImageData.width * originalImageData.height;
  const hist = new Int32Array(256);
  for (let i = 0; i < n; i++) {
    const g = Math.round(0.299*src[i*4] + 0.587*src[i*4+1] + 0.114*src[i*4+2]);
    hist[g]++;
  }
  let lo = 0, hi = 255, cum = 0;
  const pLo = n * 0.01, pHi = n * 0.99;
  for (let v = 0; v < 256; v++) {
    cum += hist[v];
    if (cum < pLo) lo = v;
    if (cum < pHi) hi = v;
  }
  hi = Math.max(hi, lo + 1);
  const range      = (hi - lo) / 255;
  const brightness = Math.round(Math.min(300, Math.max(10, (1/range)*100)));
  const contrast   = Math.round(Math.min(400, Math.max(10, 100/Math.max(0.01,range))));
  const meanG      = hist.reduce((s,v,i) => s+v*i, 0) / n;
  const gamma      = meanG < 80 ? 70 : meanG > 175 ? 130 : 100;
  let sumAll = 0;
  for (let t = 0; t < 256; t++) sumAll += t * hist[t];
  let sumB = 0, wB = 0, best = 0, otsuT = 30;
  for (let t = 0; t < 256; t++) {
    wB += hist[t]; if (!wB) continue;
    const wF = n - wB; if (!wF) break;
    sumB += t * hist[t];
    const between = wB * wF * ((sumB/wB) - ((sumAll-sumB)/wF))**2;
    if (between > best) { best = between; otsuT = t; }
  }
  otsuT = Math.round(Math.max(5, Math.min(200, otsuT * 0.35)));
  document.getElementById('brightness').value = brightness;
  document.getElementById('contrast').value   = contrast;
  document.getElementById('gamma').value       = gamma;
  document.getElementById('threshold').value   = otsuT;
  const btn = document.getElementById('btn-auto');
  btn.classList.add('active');
  setTimeout(() => btn.classList.remove('active'), 1200);
  const info = document.getElementById('auto-info');
  info.style.display = 'block';
  info.innerHTML = 'Bereik: ' + lo + '–' + hi + ' &nbsp; Gem: ' + Math.round(meanG) + '<br>' +
    'B:' + brightness + '% C:' + contrast + '% G:' + (gamma/100).toFixed(1) + ' D:' + otsuT;
  updateFilter();
}

// ── MAGNIFIER ────────────────────────────────
function toggleMagnifier() {
  magEnabled = !magEnabled;
  const btn = document.getElementById('btn-mag');
  btn.textContent = magEnabled ? 'AAN' : 'UIT';
  btn.classList.toggle('active', magEnabled);
  if (!magEnabled) magDiv.style.display = 'none';
}
function cycleMagSize() {
  magSizeIdx = (magSizeIdx + 1) % magSizes.length;
  magSize = magSizes[magSizeIdx];
  document.getElementById('mag-size').textContent = magSize;
}

// ── ZOOM ─────────────────────────────────────
function changeZoom(d) { zoom = Math.max(0.05, Math.min(10, zoom + d)); applyZoom(); }
function resetZoom()   { fitToScreen(); }
function fitToScreen() {
  if (!originalImageData) return;
  zoom = Math.min((mainEl.clientWidth-40)/canvas.width, (mainEl.clientHeight-40)/canvas.height, 1);
  applyZoom();
}
function applyZoom() {
  wrapper.style.transform = 'translate(-50%,-50%) scale(' + zoom + ')';
  document.getElementById('zoom-label').textContent = Math.round(zoom * 100) + '%';
}
mainEl.addEventListener('wheel', e => { e.preventDefault(); changeZoom(e.deltaY < 0 ? 0.1 : -0.1); }, { passive: false });

// ── ROI ──────────────────────────────────────
function toggleROIMode() {
  roiMode = !roiMode;
  calMode = false;
  document.getElementById('btn-cal').classList.remove('active');
  document.getElementById('btn-roi').classList.toggle('active', roiMode);
  uiCv.classList.toggle('active', roiMode || calMode);
  mainEl.style.cursor = roiMode ? 'crosshair' : 'crosshair';
}
function clearROI() {
  roiRect = null; roiStart = null;
  document.getElementById('roi-info').style.display = 'none';
  drawUI();
}

// ── CALIBRATION ──────────────────────────────
function toggleCalMode() {
  calMode = !calMode;
  roiMode = false;
  document.getElementById('btn-roi').classList.remove('active');
  document.getElementById('btn-cal').classList.toggle('active', calMode);
  uiCv.classList.toggle('active', roiMode || calMode);
  if (calMode) { calPoints = []; drawUI(); }
}
function clearCalibration() {
  pxPerMm = null; calPoints = [];
  document.getElementById('cal-info').style.display = 'none';
  drawUI();
}
function closeCalModal() { document.getElementById('cal-modal').classList.remove('visible'); }
function confirmCalibration() {
  const mm = parseFloat(document.getElementById('cal-mm-input').value);
  if (!mm || mm <= 0) { alert('Voer een geldige afstand in.'); return; }
  pxPerMm = calPxDist / mm;
  closeCalModal();
  const info = document.getElementById('cal-info');
  info.style.display = 'block';
  info.innerHTML = Math.round(pxPerMm) + ' px/mm &nbsp; (' + mm + ' mm = ' + Math.round(calPxDist) + ' px)';
  calMode = false;
  document.getElementById('btn-cal').classList.remove('active');
  uiCv.classList.toggle('active', roiMode || calMode);
  drawUI();
}

// ── UI CANVAS (ROI + calibration) ─────────────
function drawUI() {
  uiCtx.clearRect(0, 0, uiCv.width, uiCv.height);

  // ROI rect
  if (roiRect) {
    uiCtx.strokeStyle = 'rgba(0,229,255,0.9)';
    uiCtx.lineWidth   = 2;
    uiCtx.setLineDash([6, 3]);
    uiCtx.strokeRect(roiRect.x, roiRect.y, roiRect.w, roiRect.h);
    uiCtx.setLineDash([]);
    uiCtx.fillStyle = 'rgba(0,229,255,0.06)';
    uiCtx.fillRect(roiRect.x, roiRect.y, roiRect.w, roiRect.h);
    // Label
    uiCtx.fillStyle = 'rgba(0,229,255,0.9)';
    uiCtx.font = 'bold 11px monospace';
    uiCtx.fillText('ROI', roiRect.x + 4, roiRect.y + 14);
  }

  // Calibration points/line
  if (calPoints.length > 0) {
    for (const pt of calPoints) {
      uiCtx.beginPath();
      uiCtx.arc(pt.x, pt.y, 5, 0, Math.PI * 2);
      uiCtx.fillStyle = '#f5c542';
      uiCtx.fill();
    }
    if (calPoints.length === 2) {
      uiCtx.strokeStyle = '#f5c542';
      uiCtx.lineWidth = 2;
      uiCtx.setLineDash([]);
      uiCtx.beginPath();
      uiCtx.moveTo(calPoints[0].x, calPoints[0].y);
      uiCtx.lineTo(calPoints[1].x, calPoints[1].y);
      uiCtx.stroke();
    }
  }
  if (pxPerMm && calPoints.length === 2) {
    uiCtx.strokeStyle = '#39ff14';
    uiCtx.lineWidth = 2;
    uiCtx.beginPath();
    uiCtx.moveTo(calPoints[0].x, calPoints[0].y);
    uiCtx.lineTo(calPoints[1].x, calPoints[1].y);
    uiCtx.stroke();
  }
}

// ── CANVAS MOUSE EVENTS ───────────────────────
function canvasCoords(e) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: (e.clientX - rect.left) / zoom,
    y: (e.clientY - rect.top)  / zoom
  };
}

uiCv.addEventListener('mousedown', e => {
  const { x, y } = canvasCoords(e);
  if (roiMode) {
    roiStart = { x, y };
  } else if (calMode) {
    if (calPoints.length >= 2) calPoints = [];
    calPoints.push({ x: Math.round(x), y: Math.round(y) });
    if (calPoints.length === 2) {
      const dx = calPoints[1].x - calPoints[0].x;
      const dy = calPoints[1].y - calPoints[0].y;
      calPxDist = Math.sqrt(dx*dx + dy*dy);
      document.getElementById('cal-px-dist').textContent = Math.round(calPxDist);
      document.getElementById('cal-mm-input').value = '';
      document.getElementById('cal-modal').classList.add('visible');
    }
    drawUI();
  }
});

uiCv.addEventListener('mousemove', e => {
  const { x, y } = canvasCoords(e);

  // Magnifier (only when not in special mode)
  if (magEnabled && originalImageData && !roiMode && !calMode) {
    magDiv.style.display = 'block';
    magDiv.style.left = e.clientX + 'px';
    magDiv.style.top  = e.clientY + 'px';
    magDiv.style.width = magDiv.style.height = magSize + 'px';
    document.getElementById('info-xy').textContent = mmStr(Math.round(x)) + ', ' + mmStr(Math.round(y));
    if (processedImageData && x >= 0 && y >= 0 && x < canvas.width && y < canvas.height) {
      const idx = (Math.floor(y) * canvas.width + Math.floor(x)) * 4;
      const d = processedImageData.data;
      document.getElementById('info-px').textContent = 'R:'+d[idx]+' G:'+d[idx+1]+' B:'+d[idx+2];
    }
    const mz = parseInt(document.getElementById('magzoom').value);
    const half = magSize / 2;
    magCv.width = magCv.height = magSize;
    magCtx.save();
    magCtx.beginPath(); magCtx.arc(half, half, half, 0, Math.PI*2); magCtx.clip();
    magCtx.imageSmoothingEnabled = false;
    magCtx.drawImage(canvas, x-half/mz, y-half/mz, magSize/mz, magSize/mz, 0, 0, magSize, magSize);
    magCtx.strokeStyle = 'rgba(0,229,255,.45)'; magCtx.lineWidth = 1;
    magCtx.beginPath(); magCtx.moveTo(half,0); magCtx.lineTo(half,magSize); magCtx.stroke();
    magCtx.beginPath(); magCtx.moveTo(0,half); magCtx.lineTo(magSize,half); magCtx.stroke();
    magCtx.restore();
  } else {
    magDiv.style.display = 'none';
    document.getElementById('info-xy').textContent = mmStr(Math.round(x)) + ', ' + mmStr(Math.round(y));
  }

  if (roiMode && roiStart) {
    roiRect = {
      x: Math.min(roiStart.x, x), y: Math.min(roiStart.y, y),
      w: Math.abs(x - roiStart.x), h: Math.abs(y - roiStart.y)
    };
    drawUI();
  }
});

uiCv.addEventListener('mouseup', e => {
  if (roiMode && roiStart) {
    const { x, y } = canvasCoords(e);
    roiRect = {
      x: Math.round(Math.min(roiStart.x, x)), y: Math.round(Math.min(roiStart.y, y)),
      w: Math.round(Math.abs(x - roiStart.x)), h: Math.round(Math.abs(y - roiStart.y))
    };
    roiStart = null;
    if (roiRect.w < 5 || roiRect.h < 5) { roiRect = null; drawUI(); return; }
    const info = document.getElementById('roi-info');
    info.style.display = 'block';
    info.innerHTML = roiRect.w + 'x' + roiRect.h + ' px &nbsp; @ ' + roiRect.x + ',' + roiRect.y;
    drawUI();
    toggleROIMode(); // auto-exit ROI draw mode
  }
});

// Also handle mouse on main canvas (when ui canvas has pointer-events:none)
mainEl.addEventListener('mousemove', e => {
  if (roiMode || calMode) return; // handled by uiCv
  if (!magEnabled || !originalImageData) { magDiv.style.display = 'none'; return; }
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) / zoom;
  const y = (e.clientY - rect.top)  / zoom;
  magDiv.style.display = 'block';
  magDiv.style.left = e.clientX + 'px';
  magDiv.style.top  = e.clientY + 'px';
  magDiv.style.width = magDiv.style.height = magSize + 'px';
  document.getElementById('info-xy').textContent = mmStr(Math.round(x)) + ', ' + mmStr(Math.round(y));
  if (processedImageData && x >= 0 && y >= 0 && x < canvas.width && y < canvas.height) {
    const idx = (Math.floor(y) * canvas.width + Math.floor(x)) * 4;
    const d = processedImageData.data;
    document.getElementById('info-px').textContent = 'R:'+d[idx]+' G:'+d[idx+1]+' B:'+d[idx+2];
  }
  const mz = parseInt(document.getElementById('magzoom').value);
  const half = magSize / 2;
  magCv.width = magCv.height = magSize;
  magCtx.save();
  magCtx.beginPath(); magCtx.arc(half, half, half, 0, Math.PI*2); magCtx.clip();
  magCtx.imageSmoothingEnabled = false;
  magCtx.drawImage(canvas, x-half/mz, y-half/mz, magSize/mz, magSize/mz, 0, 0, magSize, magSize);
  magCtx.strokeStyle = 'rgba(0,229,255,.45)'; magCtx.lineWidth = 1;
  magCtx.beginPath(); magCtx.moveTo(half,0); magCtx.lineTo(half,magSize); magCtx.stroke();
  magCtx.beginPath(); magCtx.moveTo(0,half); magCtx.lineTo(magSize,half); magCtx.stroke();
  magCtx.restore();
});
mainEl.addEventListener('mouseleave', () => { magDiv.style.display = 'none'; });

function mmStr(px) {
  if (!pxPerMm) return px + 'px';
  return px + 'px (' + (px / pxPerMm).toFixed(1) + 'mm)';
}

// ── CRACK DETECTION ──────────────────────────
let cracksFound   = [];
let selectedCrack = -1;

document.getElementById('crack-minlen').addEventListener('input', function() {
  document.getElementById('val-minlen').textContent = this.value;
});
document.getElementById('crack-minaspect').addEventListener('input', function() {
  document.getElementById('val-minaspect').textContent = (this.value / 10).toFixed(1);
});
document.getElementById('crack-boxpad').addEventListener('input', function() {
  document.getElementById('val-boxpad').textContent = this.value;
  if (cracksFound.length) drawCrackBoxes(cracksFound);
});

function detectCracks() {
  if (!edgeImageData) { alert('Laad eerst een afbeelding.'); return; }
  const btn = document.getElementById('crack-run-btn');
  const lbl = document.getElementById('crack-btn-label');
  btn.disabled = true; btn.classList.add('running');
  lbl.textContent = '⟳ Bezig…';
  setTimeout(() => {
    try { _runDetection(); }
    finally { btn.disabled = false; btn.classList.remove('running'); lbl.textContent = '▶ Analyseer scheuren'; }
  }, 30);
}

function _runDetection() {
  const threshold = parseInt(document.getElementById('threshold').value);
  const minLen    = parseInt(document.getElementById('crack-minlen').value);
  const minAspect = parseFloat(document.getElementById('crack-minaspect').value) / 10;

  // Use ROI if set
  const useEdge = (currentMode === 'canny' && cannyImageData) ? cannyImageData : edgeImageData;
  const w = useEdge.width, h = useEdge.height;
  const ed = useEdge.data;
  const roi = roiRect;

  const mask = new Uint8Array(w * h);
  for (let i = 0; i < w * h; i++) {
    if (roi) {
      const px = i % w, py = Math.floor(i / w);
      if (px < roi.x || px > roi.x + roi.w || py < roi.y || py > roi.y + roi.h) continue;
    }
    mask[i] = ed[i * 4] > threshold ? 1 : 0;
  }

  const labels = new Int32Array(w * h).fill(-1);
  const compData = [];
  let nextLabel = 0;
  const queue = new Int32Array(w * h);

  for (let startY = 0; startY < h; startY++) {
    for (let startX = 0; startX < w; startX++) {
      const si = startY * w + startX;
      if (mask[si] === 0 || labels[si] !== -1) continue;
      let head = 0, tail = 0;
      queue[tail++] = si; labels[si] = nextLabel;
      let minX=startX,minY=startY,maxX=startX,maxY=startY,count=0;
      while (head < tail) {
        const cur = queue[head++];
        const cx  = cur % w, cy = (cur-cx)/w;
        count++;
        if (cx < minX) minX=cx; if (cx > maxX) maxX=cx;
        if (cy < minY) minY=cy; if (cy > maxY) maxY=cy;
        const nb = [
          cy>0&&cx>0?cur-w-1:-1, cy>0?cur-w:-1, cy>0&&cx<w-1?cur-w+1:-1,
          cx>0?cur-1:-1, cx<w-1?cur+1:-1,
          cy<h-1&&cx>0?cur+w-1:-1, cy<h-1?cur+w:-1, cy<h-1&&cx<w-1?cur+w+1:-1
        ];
        for (const n of nb) {
          if (n>=0 && mask[n]===1 && labels[n]===-1) { labels[n]=nextLabel; queue[tail++]=n; }
        }
      }
      compData.push({minX,minY,maxX,maxY,count});
      nextLabel++;
    }
  }

  const cracks = [];
  for (const c of compData) {
    const bw=c.maxX-c.minX+1, bh=c.maxY-c.minY+1;
    const length=Math.max(bw,bh), short=Math.min(bw,bh);
    const aspect=length/Math.max(1,short);
    if (length >= minLen && aspect >= minAspect) {
      const cx = Math.round(c.minX+bw/2), cy = Math.round(c.minY+bh/2);
      const lengthMm = pxPerMm ? (length/pxPerMm).toFixed(1) : null;
      cracks.push({...c,bw,bh,length,aspect,cx,cy,lengthMm});
    }
  }
  cracks.sort((a,b) => b.length - a.length);
  cracksFound = cracks; selectedCrack = -1;
  drawCrackBoxes(cracks);
  updateCrackList(cracks);
}

function severityClass(l) { return l>200?'sev-high':l>80?'sev-medium':'sev-low'; }
function severityColor(l) { return l>200?'#ff3333':l>80?'#f58a00':'#f5c542'; }

function drawCrackBoxes(cracks) {
  overlayCtx.clearRect(0, 0, overlayCv.width, overlayCv.height);
  if (!cracks.length) return;
  const pad = parseInt(document.getElementById('crack-boxpad').value);
  cracks.forEach((c, i) => {
    const x=Math.max(0,c.minX-pad), y=Math.max(0,c.minY-pad);
    const bw=Math.min(canvas.width-x,c.bw+pad*2), bh=Math.min(canvas.height-y,c.bh+pad*2);
    const col=severityColor(c.length), isSel=i===selectedCrack;
    overlayCtx.strokeStyle=col; overlayCtx.lineWidth=isSel?3:1.5;
    overlayCtx.setLineDash(isSel?[]:[4,3]); overlayCtx.strokeRect(x,y,bw,bh);
    const lbl=String(i+1);
    overlayCtx.font='bold 11px monospace';
    const tw=overlayCtx.measureText(lbl).width+6;
    overlayCtx.fillStyle=col; overlayCtx.fillRect(x,y-15,tw,14);
    overlayCtx.fillStyle='#000'; overlayCtx.fillText(lbl,x+3,y-3);
  });
  overlayCtx.setLineDash([]);
}

function updateCrackList(cracks) {
  document.getElementById('crack-count').textContent = cracks.length;
  document.getElementById('crack-results').classList.add('visible');
  document.getElementById('crack-list').innerHTML = cracks.map((c, i) => {
    const orient = c.bw > c.bh ? 'H' : 'V';
    const lenStr = c.lengthMm ? c.length + 'px (' + c.lengthMm + 'mm)' : c.length + 'px';
    return '<div class="crack-item" id="ci-'+i+'" onclick="selectCrack('+i+')">' +
      '<div class="crack-badge '+severityClass(c.length)+'">'+(i+1)+'</div>' +
      '<div class="crack-item-info">' +
      '<div class="ci-main">'+lenStr+' &nbsp; '+orient+'</div>' +
      '<div class="ci-sub">'+c.cx+','+c.cy+' &nbsp; ratio:'+c.aspect.toFixed(1)+'</div>' +
      '</div></div>';
  }).join('');
}

function selectCrack(i) {
  selectedCrack = i;
  document.querySelectorAll('.crack-item').forEach((el,j) => el.classList.toggle('selected', j===i));
  drawCrackBoxes(cracksFound);
  const c = cracksFound[i], pad = 40;
  const roi2 = Math.max(c.bw, c.bh) + pad * 2;
  zoom = Math.min((mainEl.clientWidth*0.8)/roi2, (mainEl.clientHeight*0.8)/roi2, 8);
  const scaleX = mainEl.clientWidth/2  - c.cx * zoom;
  const scaleY = mainEl.clientHeight/2 - c.cy * zoom;
  wrapper.style.transform = 'translate(calc(-50% + '+(scaleX-mainEl.clientWidth/2+mainEl.clientWidth/2)+'px),calc(-50% + '+(scaleY-mainEl.clientHeight/2+mainEl.clientHeight/2)+'px)) scale('+zoom+')';
  document.getElementById('zoom-label').textContent = Math.round(zoom*100) + '%';
}

function clearCracks() {
  cracksFound = []; selectedCrack = -1;
  overlayCtx.clearRect(0, 0, overlayCv.width, overlayCv.height);
  document.getElementById('crack-results').classList.remove('visible');
  document.getElementById('crack-list').innerHTML = '';
}

// ── EXPORT PNG ───────────────────────────────
function exportPNG() {
  if (!originalImageData) return;
  const btn = document.getElementById('export-btn');
  const fname = document.getElementById('info-file').textContent.replace(/\.\w+$/,'') || 'xray';
  const modeLabel = {original:'orig',pseudo:'pseudo',edge:'sobel',canny:'canny',edge2:'threshold',overlay:'overlay'}[currentMode];
  const ts = new Date().toISOString().slice(0,19).replace(/[:\-T]/g,'');
  const exportCv = document.createElement('canvas');
  exportCv.width = canvas.width; exportCv.height = canvas.height;
  const ectx = exportCv.getContext('2d');
  ectx.drawImage(canvas, 0, 0);
  if (cracksFound.length) ectx.drawImage(overlayCv, 0, 0);
  ectx.drawImage(uiCv, 0, 0);
  ectx.drawImage(annotCv, 0, 0);
  exportCv.toBlob(blob => {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = fname + '_' + modeLabel + '_' + ts + '.png';
    a.click(); URL.revokeObjectURL(url);
    btn.classList.add('flash');
    setTimeout(() => btn.classList.remove('flash'), 800);
  }, 'image/png');
}

// ── RAPPORT GENERATOR ────────────────────────
function generateReport() {
  if (!originalImageData) { alert('Laad eerst een afbeelding.'); return; }

  // ── Processed image (canvas + overlays + annotations) ──
  const procCv  = document.createElement('canvas');
  procCv.width  = canvas.width; procCv.height = canvas.height;
  const pctx    = procCv.getContext('2d');
  pctx.drawImage(canvas, 0, 0);
  if (cracksFound.length) pctx.drawImage(overlayCv, 0, 0);
  pctx.drawImage(uiCv, 0, 0);
  pctx.drawImage(annotCv, 0, 0);
  const procImg = procCv.toDataURL('image/png');

  // ── Original image (clean, no filters, no overlays) ──
  const origCv  = document.createElement('canvas');
  origCv.width  = canvas.width; origCv.height = canvas.height;
  const octx    = origCv.getContext('2d');
  const origID  = new ImageData(new Uint8ClampedArray(originalImageData.data), originalImageData.width, originalImageData.height);
  octx.putImageData(origID, 0, 0);
  const origImg = origCv.toDataURL('image/png');

  const fname  = document.getElementById('info-file').textContent;
  const size   = document.getElementById('info-size').textContent;
  const bits   = document.getElementById('info-bits').textContent;
  const now    = new Date().toLocaleString('nl-NL');
  const brightness = document.getElementById('brightness').value;
  const contrast   = document.getElementById('contrast').value;
  const gamma      = (parseFloat(document.getElementById('gamma').value)/100).toFixed(1);
  const threshold  = document.getElementById('threshold').value;
  const blurSigma  = document.getElementById('blur-sigma').value;
  const modeNames  = {original:'Origineel',pseudo:'Pseudo kleur',edge:'Sobel randen',canny:'Canny randen',edge2:'Sobel + drempel',overlay:'Overlay'};
  const calStr = pxPerMm ? Math.round(pxPerMm) + ' px/mm' : 'Niet gekalibreerd';
  const roiStr = roiRect  ? roiRect.w + '\xd7' + roiRect.h + ' px @ ' + roiRect.x + ',' + roiRect.y : 'Gehele afbeelding';

  const crackRows = cracksFound.map((c, i) => {
    const orient = c.bw > c.bh ? 'Horizontaal' : 'Verticaal';
    const lenStr = c.lengthMm ? c.length + ' px (' + c.lengthMm + ' mm)' : c.length + ' px';
    const sev    = c.length > 200 ? 'Hoog' : c.length > 80 ? 'Middel' : 'Laag';
    const sevCol = c.length > 200 ? '#991b1b' : c.length > 80 ? '#9a3412' : '#92400e';
    return `<tr><td>${i+1}</td><td>${lenStr}</td><td>${orient}</td><td>${c.aspect.toFixed(1)}</td><td>${c.cx}, ${c.cy}</td><td style="color:${sevCol};font-weight:bold;">${sev}</td></tr>`;
  }).join('');

  // Annotation rows
  const annRows = annotations.map((a, i) => {
    const statusHtml = a.status === 'goedgekeurd'
      ? '<span style="color:#16a34a;font-weight:bold;">&#10003; Goedgekeurd</span>'
      : a.status === 'afgekeurd'
      ? '<span style="color:#dc2626;font-weight:bold;">&#10005; Afgekeurd</span>'
      : '<span style="color:#9ca3af;">&#8212; Geen oordeel</span>';
    const comment = a.comment ? `<div style="color:#374151;font-size:11px;margin-top:4px;">${a.comment.replace(/</g,'&lt;')}</div>` : '';
    const ptStr   = a.points.length + ' punten' + (a.closed ? ' (gesloten)' : ' (open)');
    return `<tr>
      <td style="font-weight:bold;">#${i+1}</td>
      <td>${statusHtml}</td>
      <td style="font-size:11px;color:#6b7280;">${ptStr}</td>
      <td>${comment || '<span style="color:#d1d5db;">—</span>'}</td>
    </tr>`;
  }).join('');

  // Overall verdict for cover page
  const nApproved = annotations.filter(a => a.status === 'goedgekeurd').length;
  const nRejected = annotations.filter(a => a.status === 'afgekeurd').length;
  let verdictHtml = '';
  if (annotations.length > 0) {
    if (nRejected > 0) {
      verdictHtml = '<div style="margin-top:20px;padding:12px 18px;background:rgba(220,38,38,.15);border-left:4px solid #dc2626;border-radius:0 4px 4px 0;font-size:14px;"><strong style="color:#fca5a5;">AFGEKEURD</strong> &mdash; ' + nRejected + ' annotatie(s) met afkeur</div>';
    } else if (nApproved > 0) {
      verdictHtml = '<div style="margin-top:20px;padding:12px 18px;background:rgba(22,163,74,.12);border-left:4px solid #16a34a;border-radius:0 4px 4px 0;font-size:14px;"><strong style="color:#86efac;">GOEDGEKEURD</strong> &mdash; alle annotaties goedgekeurd</div>';
    }
  }

  const reportHtml = `<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<title>Analyserapport \u2014 ${fname}</title>
<style>
  *{box-sizing:border-box;}
  body{font-family:'Segoe UI',Arial,sans-serif;margin:0;padding:0;color:#1a1a2e;background:#fff;}
  .cover{background:linear-gradient(135deg,#0a0c0f 0%,#0f1318 60%,#1e2630 100%);
    color:#fff;padding:40px 48px;page-break-after:always;}
  .cover h1{font-size:28px;letter-spacing:4px;text-transform:uppercase;color:#00e5ff;margin:0 0 4px;}
  .cover .sub{font-size:12px;color:#4a5568;letter-spacing:2px;text-transform:uppercase;}
  .cover .meta{margin-top:28px;font-size:12px;color:#b8c5d0;line-height:2.1;}
  .cover .meta strong{color:#fff;display:inline-block;min-width:110px;}
  section{padding:28px 48px;}
  section+section{border-top:1px solid #e5e7eb;}
  h2{font-size:13px;letter-spacing:3px;text-transform:uppercase;color:#0a0c0f;
    margin:0 0 16px;padding-bottom:8px;border-bottom:2px solid #00e5ff;}
  /* SIDE BY SIDE */
  .img-pair{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:8px;}
  .img-card{border:1px solid #e5e7eb;border-radius:6px;overflow:hidden;}
  .img-card .img-label{background:#f9fafb;padding:8px 12px;font-size:10px;
    text-transform:uppercase;letter-spacing:1px;color:#6b7280;font-weight:600;border-bottom:1px solid #e5e7eb;}
  .img-card img{width:100%;display:block;}
  /* TABLES */
  table{width:100%;border-collapse:collapse;font-size:12px;}
  th{background:#f3f4f6;padding:8px 12px;text-align:left;font-weight:600;
    font-size:11px;text-transform:uppercase;letter-spacing:1px;color:#6b7280;}
  td{padding:8px 12px;border-bottom:1px solid #f3f4f6;vertical-align:top;}
  tr:last-child td{border-bottom:none;}
  tr:hover td{background:#fafafa;}
  /* SETTINGS */
  .settings-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
  .setting{background:#f9fafb;border-radius:4px;padding:10px 14px;}
  .setting .name{font-size:10px;text-transform:uppercase;letter-spacing:1px;color:#9ca3af;}
  .setting .value{font-size:14px;font-weight:600;color:#111827;margin-top:2px;}
  /* SUMMARY STATS */
  .summary-row{display:flex;gap:16px;margin-bottom:16px;flex-wrap:wrap;}
  .stat{background:#f3f4f6;border-radius:6px;padding:10px 16px;flex:1;text-align:center;min-width:80px;}
  .stat .n{font-size:26px;font-weight:bold;color:#0a0c0f;}
  .stat .lbl{font-size:10px;text-transform:uppercase;letter-spacing:1px;color:#9ca3af;}
  /* ANNOTATION ITEMS */
  .ann-block{border-radius:6px;border:1px solid #e5e7eb;padding:14px 18px;margin-bottom:10px;}
  .ann-block.approved{border-left:4px solid #16a34a;}
  .ann-block.rejected{border-left:4px solid #dc2626;}
  /* FOOTER */
  .footer{background:#f9fafb;padding:14px 48px;font-size:10px;color:#9ca3af;
    border-top:1px solid #e5e7eb;display:flex;justify-content:space-between;align-items:center;}
  @media print{
    .no-print{display:none!important;}
    section{break-inside:avoid;}
    .img-pair{grid-template-columns:1fr 1fr;}
  }
</style>
</head>
<body>

<div class="cover">
  <div class="sub">Analyserapport</div>
  <h1>R\xf6ntgen Analyse</h1>
  <div class="sub">Kogelwerende Plaat Inspectie</div>
  <div class="meta">
    <strong>Bestand:</strong> ${fname}<br>
    <strong>Afmeting:</strong> ${size}<br>
    <strong>Bit-diepte:</strong> ${bits}<br>
    <strong>Weergave:</strong> ${modeNames[currentMode] || currentMode}<br>
    <strong>Datum:</strong> ${now}<br>
    <strong>Kalibratie:</strong> ${calStr}<br>
    <strong>ROI:</strong> ${roiStr}<br>
    <strong>Annotaties:</strong> ${annotations.length} (${nApproved} goed, ${nRejected} afgekeurd)
  </div>
  ${verdictHtml}
</div>

<section>
  <h2>Afbeeldingen</h2>
  <div class="img-pair">
    <div class="img-card">
      <div class="img-label">Origineel (geen filters)</div>
      <img src="${origImg}" alt="Originele r\xf6ntgenfoto">
    </div>
    <div class="img-card">
      <div class="img-label">Analyse (filters + annotaties)</div>
      <img src="${procImg}" alt="Bewerkte r\xf6ntgenfoto met analyse">
    </div>
  </div>
</section>

<section>
  <h2>Filterinstellingen</h2>
  <div class="settings-grid">
    <div class="setting"><div class="name">Helderheid</div><div class="value">${brightness}%</div></div>
    <div class="setting"><div class="name">Contrast</div><div class="value">${contrast}%</div></div>
    <div class="setting"><div class="name">Gamma</div><div class="value">${gamma}</div></div>
    <div class="setting"><div class="name">Sobel drempel</div><div class="value">${threshold}</div></div>
    <div class="setting"><div class="name">Gaussische blur \u03c3</div><div class="value">${blurSigma}</div></div>
    <div class="setting"><div class="name">CLAHE</div><div class="value">${claheEnabled ? 'Aan' : 'Uit'}</div></div>
  </div>
</section>

<section>
  <h2>Annotaties \u2014 ${annotations.length} gebieden</h2>
  ${annotations.length === 0
    ? '<p style="color:#9ca3af;font-size:12px;">Geen annotaties geplaatst.</p>'
    : `<table>
        <thead><tr><th>#</th><th>Oordeel</th><th>Geometrie</th><th>Opmerking</th></tr></thead>
        <tbody>${annRows}</tbody>
      </table>`}
</section>

<section>
  <h2>Scheurdetectie \u2014 ${cracksFound.length} kandidaten</h2>
  ${cracksFound.length === 0
    ? '<p style="color:#9ca3af;font-size:12px;">Geen scheurkandidaten of analyse niet uitgevoerd.</p>'
    : `<div class="summary-row">
        <div class="stat"><div class="n">${cracksFound.length}</div><div class="lbl">Totaal</div></div>
        <div class="stat"><div class="n">${cracksFound.filter(c=>c.length>200).length}</div><div class="lbl">Hoog</div></div>
        <div class="stat"><div class="n">${cracksFound.filter(c=>c.length>80&&c.length<=200).length}</div><div class="lbl">Middel</div></div>
        <div class="stat"><div class="n">${cracksFound.filter(c=>c.length<=80).length}</div><div class="lbl">Laag</div></div>
        ${pxPerMm ? '<div class="stat"><div class="n">'+(cracksFound[0].length/pxPerMm).toFixed(1)+'mm</div><div class="lbl">Langste</div></div>' : ''}
      </div>
      <table>
        <thead><tr><th>#</th><th>Lengte</th><th>Ori\xebntatie</th><th>Ratio</th><th>Positie</th><th>Ernst</th></tr></thead>
        <tbody>${crackRows}</tbody>
      </table>`}
</section>

<div class="footer">
  <div class="no-print">
    <button onclick="window.print()" style="padding:7px 18px;background:#0a0c0f;color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:12px;margin-right:8px;">&#128438; PDF opslaan</button>
  </div>
  <div>Gegenereerd door XRAY-ANALYZE &mdash; ${now}</div>
</div>

</body></html>`;

  const win = window.open('', '_blank');
  win.document.write(reportHtml);
  win.document.close();
}



// ── ANNOTATION / POLYLINE ─────────────────────────────────────────────────
const annotCv  = document.getElementById('annotCanvas');
const annotCtx = annotCv.getContext('2d');

let annotations    = [];
let currentPoly    = [];
let polyMode       = false;
let annStatus      = null;
let polyMousePt    = null;

function togglePolyMode() {
  if (polyMode) { cancelPoly(); return; }
  if (roiMode)  toggleROIMode();
  if (calMode)  toggleCalMode();
  polyMode = true;
  currentPoly = [];
  document.getElementById('btn-poly').classList.add('active');
  document.getElementById('btn-poly').innerHTML = '&#9632; Stop';
  document.getElementById('btn-poly-done').style.display = '';
  document.getElementById('btn-poly-cancel').style.display = '';
  document.getElementById('poly-hint').classList.add('visible');
  document.getElementById('poly-pt-count').textContent = '0';
  annotCv.classList.add('active');
}

function cancelPoly() {
  polyMode = false; currentPoly = []; polyMousePt = null;
  document.getElementById('btn-poly').classList.remove('active');
  document.getElementById('btn-poly').innerHTML = '&#9998; Teken';
  document.getElementById('btn-poly-done').style.display = 'none';
  document.getElementById('btn-poly-cancel').style.display = 'none';
  document.getElementById('poly-hint').classList.remove('visible');
  annotCv.classList.remove('active');
  drawAnnotations();
}

function setAnnStatus(s) {
  annStatus = s;
  document.getElementById('ann-approve').classList.toggle('active', s === 'goedgekeurd');
  document.getElementById('ann-reject').classList.toggle('active',  s === 'afgekeurd');
  document.getElementById('ann-neutral').classList.toggle('active', s === null);
}

function finishAnnotation() {
  if (currentPoly.length < 2) { cancelPoly(); return; }
  const comment = document.getElementById('ann-comment').value.trim();
  annotations.push({
    points:  currentPoly.slice(),
    status:  annStatus,
    comment: comment,
    closed:  currentPoly.length >= 3,
    id:      Date.now()
  });
  document.getElementById('ann-comment').value = '';
  cancelPoly();
  drawAnnotations();
  renderAnnotList();
}

function deleteAnnotation(id) {
  annotations = annotations.filter(a => a.id !== id);
  drawAnnotations();
  renderAnnotList();
}

function clearAnnotations() {
  annotations = [];
  if (annotCtx && annotCv.width) annotCtx.clearRect(0, 0, annotCv.width, annotCv.height);
  renderAnnotList();
}

// ── DRAW ENGINE ──────────────────────────────
function drawAnnotations() {
  if (!annotCv.width) return;
  annotCtx.clearRect(0, 0, annotCv.width, annotCv.height);
  const offset = canvas.width * 0.02;

  for (const ann of annotations) {
    if (ann.points.length < 1) continue;
    _drawOnePoly(ann.points, ann.closed, offset, false, ann);
  }

  if (polyMode && currentPoly.length > 0) {
    const preview = polyMousePt ? [...currentPoly, polyMousePt] : currentPoly;
    _drawOnePoly(preview, false, offset, true, null);
    for (const pt of currentPoly) {
      annotCtx.beginPath();
      annotCtx.arc(pt.x, pt.y, 4, 0, Math.PI * 2);
      annotCtx.fillStyle = 'rgba(255,80,80,0.9)';
      annotCtx.fill();
    }
  }
}

function _drawOnePoly(pts, closed, offset, isPreview, ann) {
  if (pts.length < 1) return;

  // Thin solid inner line
  annotCtx.beginPath();
  annotCtx.moveTo(pts[0].x, pts[0].y);
  for (let i = 1; i < pts.length; i++) annotCtx.lineTo(pts[i].x, pts[i].y);
  if (closed) annotCtx.closePath();
  annotCtx.strokeStyle = isPreview ? 'rgba(255,100,100,0.5)' : 'rgba(255,60,60,0.8)';
  annotCtx.lineWidth   = 1.5;
  annotCtx.setLineDash([]);
  annotCtx.lineJoin    = 'round';
  annotCtx.stroke();

  if (pts.length < 2) return;

  // Red dashed halo at 2% offset distance
  annotCtx.beginPath();
  annotCtx.moveTo(pts[0].x, pts[0].y);
  for (let i = 1; i < pts.length; i++) annotCtx.lineTo(pts[i].x, pts[i].y);
  if (closed) annotCtx.closePath();
  annotCtx.strokeStyle = isPreview ? 'rgba(255,80,80,0.22)' : 'rgba(255,30,30,0.55)';
  annotCtx.lineWidth   = offset * 2;
  annotCtx.setLineDash([Math.max(8, offset * 0.6), Math.max(5, offset * 0.4)]);
  annotCtx.lineCap     = 'round';
  annotCtx.lineJoin    = 'round';
  annotCtx.stroke();
  annotCtx.setLineDash([]);
  annotCtx.lineCap     = 'butt';

  // Status dot at centroid
  if (!isPreview && ann && ann.status) {
    const cx = pts.reduce((s, p) => s + p.x, 0) / pts.length;
    const cy = pts.reduce((s, p) => s + p.y, 0) / pts.length;
    const col = ann.status === 'goedgekeurd' ? '#39ff14' : '#ff4444';
    const r   = Math.max(10, offset * 0.55);
    annotCtx.beginPath();
    annotCtx.arc(cx, cy, r, 0, Math.PI * 2);
    annotCtx.fillStyle = col;
    annotCtx.globalAlpha = 0.88;
    annotCtx.fill();
    annotCtx.globalAlpha = 1;
    annotCtx.fillStyle    = '#000';
    annotCtx.font         = `bold ${Math.round(r * 1.3)}px monospace`;
    annotCtx.textAlign    = 'center';
    annotCtx.textBaseline = 'middle';
    annotCtx.fillText(ann.status === 'goedgekeurd' ? '\u2713' : '\u2717', cx, cy);
    annotCtx.textAlign    = 'left';
    annotCtx.textBaseline = 'alphabetic';
  }
}

// ── ANNOTATION LIST ───────────────────────────
function renderAnnotList() {
  const list = document.getElementById('ann-list');
  if (!list) return;
  if (!annotations.length) { list.innerHTML = ''; return; }
  list.innerHTML = annotations.map((a, i) => {
    const cls   = a.status === 'goedgekeurd' ? 'approved' : a.status === 'afgekeurd' ? 'rejected' : '';
    const badge = a.status === 'goedgekeurd'
      ? '<span class="ann-badge ok">&#10003; Goedgekeurd</span>'
      : a.status === 'afgekeurd'
      ? '<span class="ann-badge nok">&#10005; Afgekeurd</span>'
      : '<span class="ann-badge none">Geen oordeel</span>';
    const cmt = a.comment ? `<div class="ann-comment-text">${escHtml(a.comment)}</div>` : '';
    return `<div class="ann-item ${cls}">
      <button class="ann-del" onclick="deleteAnnotation(${a.id})" title="Verwijder">&#10005;</button>
      <div class="ann-header"><span class="ann-num">#${i+1}</span>${badge}</div>
      ${cmt}
      <div class="ann-pts">${a.points.length} punten${a.closed?' (gesloten)':''}</div>
    </div>`;
  }).join('');
}

function escHtml(s) {
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

// ── ANNOT CANVAS EVENTS ───────────────────────
let _lastClickTime = 0;
annotCv.addEventListener('click', e => {
  if (!polyMode) return;
  const now2 = Date.now();
  // Ignore the click that fires right before/after dblclick
  if (now2 - _lastClickTime < 300) return;
  _lastClickTime = now2;
  const { x, y } = canvasCoords(e);
  currentPoly.push({ x: Math.round(x), y: Math.round(y) });
  document.getElementById('poly-pt-count').textContent = currentPoly.length;
  drawAnnotations();
});

annotCv.addEventListener('dblclick', e => {
  if (!polyMode) return;
  _lastClickTime = Date.now();
  // Remove last point added by the click that preceded dblclick
  if (currentPoly.length > 0) currentPoly.pop();
  finishAnnotation();
});

annotCv.addEventListener('mousemove', e => {
  if (!polyMode) return;
  const { x, y } = canvasCoords(e);
  polyMousePt = { x, y };
  drawAnnotations();
  document.getElementById('info-xy').textContent = mmStr(Math.round(x)) + ', ' + mmStr(Math.round(y));
});

annotCv.addEventListener('mouseleave', () => {
  polyMousePt = null;
  if (polyMode) drawAnnotations();
});

// ── KEYBOARD SHORTCUTS ────────────────────────
document.addEventListener('keydown', e => {
  if (e.target.tagName === 'INPUT') return;
  if (e.key==='1') setMode('original');
  if (e.key==='2') setMode('pseudo');
  if (e.key==='3') setMode('edge');
  if (e.key==='4') setMode('canny');
  if (e.key==='5') setMode('edge2');
  if (e.key==='6') setMode('overlay');
  if (e.key==='m'||e.key==='M') toggleMagnifier();
  if (e.key==='r'||e.key==='R') toggleROIMode();
  if (e.key==='c'||e.key==='C') toggleCalMode();
  if (e.key==='+'||e.key==='=') changeZoom(0.15);
  if (e.key==='-') changeZoom(-0.15);
  if (e.key==='f'||e.key==='F') fitToScreen();
  if (e.key==='p'||e.key==='P') togglePolyMode();
  if (e.key==='Escape') { if(roiMode) toggleROIMode(); if(calMode) toggleCalMode(); if(polyMode) cancelPoly(); closeCalModal(); }
});

function showLoader(v) { document.getElementById('loader').classList.toggle('visible', v); }
</script>
</body>
</html>
